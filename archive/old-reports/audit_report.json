{
  "audit_metadata": {
    "timestamp": "2025-08-17T13:33:40.628007",
    "version": "Q2-2025-ML-MODERNIZATION",
    "auditor": "Claude Code Assistant",
    "base_path": "C:\\Users\\Ana\\Meu Drive\\Site roteiro de dispensa√ß√£o",
    "duration_seconds": 0.06,
    "completion_time": "2025-08-17T13:33:40.691283"
  },
  "data_audit": {
    "total_files": 9,
    "total_size_mb": 0.09229850769042969,
    "files_analysis": {
      "clinical_taxonomy.json": {
        "size_mb": 0.011,
        "size_bytes": 11947,
        "last_modified": "2025-07-27T12:36:30.281189",
        "structure_type": "dict",
        "total_entries": 1,
        "estimated_tokens": 2044,
        "completeness_score": 100.0,
        "unique_fields": [
          "clinical_taxonomy"
        ],
        "missing_required_fields": [],
        "is_target_file": true
      },
      "dispensing_workflow.json": {
        "size_mb": 0.011,
        "size_bytes": 11583,
        "last_modified": "2025-07-27T12:32:54.292425",
        "structure_type": "dict",
        "total_entries": 4,
        "estimated_tokens": 1983,
        "completeness_score": 100.0,
        "unique_fields": [
          "dispensing_workflow",
          "quality_indicators",
          "workflow_optimization",
          "emergency_protocols"
        ],
        "missing_required_fields": [],
        "is_target_file": true
      },
      "dosing_protocols.json": {
        "size_mb": 0.007,
        "size_bytes": 7440,
        "last_modified": "2025-07-27T12:29:46.791105",
        "structure_type": "dict",
        "total_entries": 5,
        "estimated_tokens": 1289,
        "completeness_score": 100.0,
        "unique_fields": [
          "dosing_protocols",
          "administration_guidelines",
          "dispensing_schedule",
          "monitoring_schedule",
          "quality_assurance"
        ],
        "missing_required_fields": [],
        "is_target_file": true
      },
      "frequently_asked_questions.json": {
        "size_mb": 0.014,
        "size_bytes": 14446,
        "last_modified": "2025-07-27T12:41:21.824784",
        "structure_type": "dict",
        "total_entries": 1,
        "estimated_tokens": 3141,
        "completeness_score": 100.0,
        "unique_fields": [
          "faq_hanseniase_pqtu"
        ],
        "missing_required_fields": [],
        "is_target_file": true
      },
      "hanseniase_catalog.json": {
        "size_mb": 0.008,
        "size_bytes": 8100,
        "last_modified": "2025-07-27T12:28:47.393565",
        "structure_type": "dict",
        "total_entries": 6,
        "estimated_tokens": 1581,
        "completeness_score": 100.0,
        "unique_fields": [
          "document_info",
          "clinical_presentations",
          "medications",
          "dispensing_protocol",
          "safety_profile",
          "clinical_references"
        ],
        "missing_required_fields": [],
        "is_target_file": true
      },
      "knowledge_scope_limitations.json": {
        "size_mb": 0.01,
        "size_bytes": 10364,
        "last_modified": "2025-07-27T12:42:34.625339",
        "structure_type": "dict",
        "total_entries": 1,
        "estimated_tokens": 1794,
        "completeness_score": 100.0,
        "unique_fields": [
          "knowledge_scope_limitations"
        ],
        "missing_required_fields": [],
        "is_target_file": true
      },
      "medications_mechanisms.json": {
        "size_mb": 0.01,
        "size_bytes": 10356,
        "last_modified": "2025-07-27T12:31:19.408155",
        "structure_type": "dict",
        "total_entries": 3,
        "estimated_tokens": 1869,
        "completeness_score": 100.0,
        "unique_fields": [
          "medications",
          "combination_rationale",
          "therapeutic_monitoring"
        ],
        "missing_required_fields": [],
        "is_target_file": true
      },
      "pharmacovigilance_guidelines.json": {
        "size_mb": 0.011,
        "size_bytes": 11355,
        "last_modified": "2025-07-27T12:34:19.012701",
        "structure_type": "dict",
        "total_entries": 1,
        "estimated_tokens": 1902,
        "completeness_score": 100.0,
        "unique_fields": [
          "pharmacovigilance_guidelines"
        ],
        "missing_required_fields": [],
        "is_target_file": true
      },
      "quick_reference_protocols.json": {
        "size_mb": 0.011,
        "size_bytes": 11191,
        "last_modified": "2025-07-27T12:39:20.604365",
        "structure_type": "dict",
        "total_entries": 1,
        "estimated_tokens": 2022,
        "completeness_score": 100.0,
        "unique_fields": [
          "quick_reference_protocols"
        ],
        "missing_required_fields": [],
        "is_target_file": true
      }
    },
    "schema_validation": {},
    "data_quality_score": 100.0,
    "total_estimated_tokens": 17625,
    "target_files_found": 9,
    "target_files_missing": []
  },
  "documents_audit": {
    "total_documents": 3,
    "documents_analysis": {
      "Roteiro de Dsispensa√ß√£o - Hansen√≠ase.md": {
        "exists": true,
        "size_mb": 0.011,
        "size_bytes": 11861,
        "last_modified": "2025-07-24T22:49:45.844033",
        "extension": ".md",
        "total_lines": 277,
        "total_characters": 11208,
        "estimated_tokens": 2802,
        "structure": {
          "total_headers": 22,
          "header_levels": {
            "1": 2,
            "2": 7,
            "3": 9,
            "4": 4
          },
          "topics": [
            {
              "level": 1,
              "title": "ROTEIRO PARA DISPENSA√á√ÉO - HANSEN√çASE (PQT-U)"
            },
            {
              "level": 2,
              "title": "APRESENTA√á√ïES DISPON√çVEIS (Fontes: 1-3):"
            },
            {
              "level": 2,
              "title": "ETAPA 01 - AVALIA√á√ÉO INICIAL"
            },
            {
              "level": 2,
              "title": "ETAPA 02 - ORIENTA√á√ïES E PLANO DE CUIDADO"
            },
            {
              "level": 3,
              "title": "INDICA√á√ïES (Fontes: 2, 7-9)"
            },
            {
              "level": 3,
              "title": "EFIC√ÅCIA E MODO DE USO (2, 7)"
            },
            {
              "level": 4,
              "title": "PARA ADULTOS (> 50 kg)"
            },
            {
              "level": 4,
              "title": "PARA CRIAN√áAS ou ADULTOS (30 a 50 kg)"
            },
            {
              "level": 4,
              "title": "PARA CRIAN√áAS < 30 kg"
            },
            {
              "level": 3,
              "title": "N√ÉO FARMACOL√ìGICAS (2, 9)"
            },
            {
              "level": 3,
              "title": "ARMAZENAMENTO E DESCARTE (13)"
            },
            {
              "level": 2,
              "title": "SEGURAN√áA"
            },
            {
              "level": 2,
              "title": "POPULA√á√ïES ESPECIAIS"
            },
            {
              "level": 2,
              "title": "ETAPA 03 - P√ìS-DISPENSA√á√ÉO E AVALIA√á√ÉO"
            },
            {
              "level": 4,
              "title": "ORIENTA√á√ïES/INTERVEN√á√ïES ESSENCIAIS (2, 9):"
            },
            {
              "level": 3,
              "title": "EVENTOS ADVERSOS MAIS COMUNS (ANVISA - 14):"
            },
            {
              "level": 3,
              "title": "EM CADA DISPENSA√á√ÉO (2, 9):"
            },
            {
              "level": 1,
              "title": "BLOCO CLOFAZIMINA"
            },
            {
              "level": 3,
              "title": "APRESENTA√á√ÉO (1-3)"
            },
            {
              "level": 3,
              "title": "INDICA√á√ïES (2, 7, 17)"
            },
            {
              "level": 3,
              "title": "MODO DE USO (2, 10, 17, 18)"
            },
            {
              "level": 2,
              "title": "CITAS/FONTES DO DOCUMENTO"
            }
          ]
        }
      },
      "Roteiro de Dsispensa√ß√£o - Hansen√≠ase.pdf": {
        "exists": true,
        "size_mb": 0.965,
        "size_bytes": 1012182,
        "last_modified": "2025-07-13T10:37:05.159144",
        "extension": ".pdf",
        "note": "PDF analysis requires external libraries"
      },
      "roteiro_hanseniase_basico.md": {
        "exists": true,
        "size_mb": 0.001,
        "size_bytes": 1457,
        "last_modified": "2025-07-27T10:49:14.170970",
        "extension": ".md",
        "total_lines": 52,
        "total_characters": 1364,
        "estimated_tokens": 341,
        "structure": {
          "total_headers": 10,
          "header_levels": {
            "1": 1,
            "2": 1,
            "3": 3,
            "4": 5
          },
          "topics": [
            {
              "level": 1,
              "title": "Roteiro de Dispensa√ß√£o para Hansen√≠ase"
            },
            {
              "level": 2,
              "title": "Sobre a Hansen√≠ase"
            },
            {
              "level": 3,
              "title": "Tratamento PQT-U (Poliquimioterapia √önica)"
            },
            {
              "level": 4,
              "title": "Esquema Adulto:"
            },
            {
              "level": 4,
              "title": "Esquema Infantil:"
            },
            {
              "level": 3,
              "title": "Orienta√ß√µes de Dispensa√ß√£o"
            },
            {
              "level": 3,
              "title": "Medicamentos"
            },
            {
              "level": 4,
              "title": "Rifampicina"
            },
            {
              "level": 4,
              "title": "Dapsona"
            },
            {
              "level": 4,
              "title": "Clofazimina"
            }
          ]
        }
      }
    },
    "content_structure": {}
  },
  "backend_services_audit": {
    "total_services": 18,
    "services_analysis": {
      "advanced_cache.py": {
        "size_kb": 6.93,
        "last_modified": "2025-08-02T23:01:22.733046",
        "is_critical": false,
        "classes": [
          "PerformanceCache"
        ],
        "functions": [],
        "imports": [
          "import time",
          "import json",
          "import hashlib",
          "from datetime import datetime, timedelta",
          "from collections import OrderedDict",
          "import threading",
          "import logging"
        ],
        "external_apis": [],
        "cache_usage": true,
        "lines_of_code": 157
      },
      "ai_provider_manager.py": {
        "size_kb": 19.97,
        "last_modified": "2025-08-10T11:56:36.331477",
        "is_critical": false,
        "classes": [
          "ProviderStatus",
          "CircuitBreakerState",
          "CircuitBreaker",
          "ModelConfig",
          "AIProviderManager"
        ],
        "functions": [
          "get_ai_health_status"
        ],
        "imports": [
          "import os",
          "import time",
          "import logging",
          "import asyncio",
          "from typing import Dict, List, Optional, Union, Tuple",
          "from datetime import datetime, timedelta",
          "from dataclasses import dataclass",
          "from enum import Enum",
          "import requests"
        ],
        "external_apis": [
          "api_key",
          "endpoint",
          "requests"
        ],
        "cache_usage": false,
        "lines_of_code": 406
      },
      "chatbot.py": {
        "size_kb": 18.2,
        "last_modified": "2025-08-16T01:02:00.181840",
        "is_critical": false,
        "classes": [
          "ChatbotService"
        ],
        "functions": [
          "create_chatbot_service"
        ],
        "imports": [
          "import os",
          "import json",
          "import logging",
          "from typing import Dict, List, Optional, Tuple",
          "from datetime import datetime",
          "import requests",
          "from pathlib import Path",
          "import numpy as np",
          "from sklearn.feature_extraction.text import TfidfVectorizer",
          "from sklearn.metrics.pairwise import cosine_similarity",
          "from ..config.personas import get_persona_by_id",
          "from ..core.security.medical_audit_logger import ("
        ],
        "external_apis": [
          "api_key",
          "requests"
        ],
        "cache_usage": true,
        "lines_of_code": 304
      },
      "dr_gasnelio_enhanced.py": {
        "size_kb": 2.01,
        "last_modified": "2025-08-02T23:01:22.734193",
        "is_critical": false,
        "classes": [],
        "functions": [
          "get_enhanced_dr_gasnelio_prompt",
          "validate_dr_gasnelio_response"
        ],
        "imports": [],
        "external_apis": [],
        "cache_usage": false,
        "lines_of_code": 44
      },
      "embeddings_api.py": {
        "size_kb": 3.45,
        "last_modified": "2025-08-13T19:53:25.962026",
        "is_critical": false,
        "classes": [
          "HuggingFaceEmbeddings"
        ],
        "functions": [
          "get_text_embedding",
          "get_batch_embeddings"
        ],
        "imports": [
          "import os",
          "import requests",
          "import logging",
          "from typing import List, Optional",
          "from cachetools import TTLCache"
        ],
        "external_apis": [
          "api_key",
          "requests"
        ],
        "cache_usage": true,
        "lines_of_code": 70
      },
      "embedding_rag_system.py": {
        "size_kb": 14.56,
        "last_modified": "2025-08-10T13:33:42.706773",
        "is_critical": false,
        "classes": [
          "EmbeddingRAGSystem"
        ],
        "functions": [
          "get_embedding_rag",
          "get_rag_context"
        ],
        "imports": [
          "import logging",
          "from typing import List, Dict, Optional, Tuple, Any",
          "from datetime import datetime",
          "import os",
          "from services.semantic_search import get_semantic_search, SearchResult",
          "from services.medical_chunking import MedicalChunk, MedicalChunker"
        ],
        "external_apis": [],
        "cache_usage": true,
        "lines_of_code": 290
      },
      "embedding_service.py": {
        "size_kb": 27.18,
        "last_modified": "2025-08-14T23:40:35.132731",
        "is_critical": true,
        "classes": [
          "EmbeddingCache",
          "EmbeddingService"
        ],
        "functions": [
          "_test_sentence_transformers",
          "_lazy_import_sentence_transformers",
          "get_embedding_service",
          "is_embeddings_available",
          "get_embedding_stats",
          "embed_text",
          "embed_texts_batch",
          "test_embeddings_system",
          "embed_texts"
        ],
        "imports": [
          "import os",
          "import pickle",
          "import logging",
          "import hashlib",
          "from typing import List, Dict, Optional, Tuple, Any, Union",
          "from datetime import datetime, timedelta",
          "from pathlib import Path",
          "import threading"
        ],
        "external_apis": [],
        "cache_usage": true,
        "lines_of_code": 544
      },
      "enhanced_rag_system.py": {
        "size_kb": 5.53,
        "last_modified": "2025-08-02T23:01:22.734193",
        "is_critical": true,
        "classes": [
          "EnhancedRAGSystem"
        ],
        "functions": [
          "get_enhanced_context",
          "cache_rag_response",
          "add_rag_feedback",
          "get_rag_stats"
        ],
        "imports": [
          "from typing import Dict, List, Optional",
          "from datetime import datetime",
          "from collections import defaultdict",
          "import json",
          "import re"
        ],
        "external_apis": [
          "requests"
        ],
        "cache_usage": true,
        "lines_of_code": 112
      },
      "ga_enhanced.py": {
        "size_kb": 2.54,
        "last_modified": "2025-08-02T23:01:22.734193",
        "is_critical": false,
        "classes": [],
        "functions": [
          "get_enhanced_ga_prompt",
          "validate_ga_response"
        ],
        "imports": [],
        "external_apis": [],
        "cache_usage": false,
        "lines_of_code": 57
      },
      "knowledge_loader.py": {
        "size_kb": 13.84,
        "last_modified": "2025-08-02T23:01:22.734193",
        "is_critical": false,
        "classes": [
          "StructuredKnowledgeBase"
        ],
        "functions": [
          "get_structured_knowledge_base"
        ],
        "imports": [
          "import json",
          "import os",
          "import logging",
          "from typing import Dict, List, Any"
        ],
        "external_apis": [],
        "cache_usage": false,
        "lines_of_code": 223
      },
      "medical_chunking.py": {
        "size_kb": 18.59,
        "last_modified": "2025-08-10T10:23:35.834057",
        "is_critical": false,
        "classes": [
          "ChunkPriority",
          "MedicalChunk",
          "MedicalChunker"
        ],
        "functions": [
          "chunk_medical_text",
          "chunk_medical_document",
          "process_medical_table"
        ],
        "imports": [
          "import re",
          "from typing import List, Dict, Any, Tuple, Optional",
          "from dataclasses import dataclass",
          "from enum import Enum",
          "import logging",
          "from app_config import config"
        ],
        "external_apis": [],
        "cache_usage": false,
        "lines_of_code": 337
      },
      "medical_rag_integration.py": {
        "size_kb": 11.96,
        "last_modified": "2025-08-10T16:42:47.123915",
        "is_critical": true,
        "classes": [
          "MedicalRAGSystem"
        ],
        "functions": [
          "get_medical_context",
          "get_medical_stats",
          "reload_medical_knowledge"
        ],
        "imports": [
          "import os",
          "import json",
          "from typing import List, Dict, Tuple, Optional",
          "from dataclasses import asdict",
          "import logging",
          "from services.medical_chunking import medical_chunker, MedicalChunk, chunk_medical_document",
          "from app_config import config"
        ],
        "external_apis": [],
        "cache_usage": false,
        "lines_of_code": 217
      },
      "openai_integration.py": {
        "size_kb": 2.44,
        "last_modified": "2025-08-02T23:01:22.734193",
        "is_critical": false,
        "classes": [],
        "functions": [
          "test_openai_connection",
          "get_ai_response_mock"
        ],
        "imports": [
          "import os",
          "import logging"
        ],
        "external_apis": [
          "openai",
          "api_key"
        ],
        "cache_usage": false,
        "lines_of_code": 53
      },
      "personas.py": {
        "size_kb": 2.8,
        "last_modified": "2025-08-02T23:01:22.734193",
        "is_critical": false,
        "classes": [],
        "functions": [
          "get_personas",
          "get_persona_prompt",
          "validate_persona",
          "get_persona_capabilities"
        ],
        "imports": [],
        "external_apis": [],
        "cache_usage": false,
        "lines_of_code": 62
      },
      "scope_detection_system.py": {
        "size_kb": 4.42,
        "last_modified": "2025-08-02T23:01:22.734193",
        "is_critical": false,
        "classes": [],
        "functions": [
          "detect_question_scope",
          "get_limitation_response"
        ],
        "imports": [
          "import re",
          "from typing import Dict, List"
        ],
        "external_apis": [],
        "cache_usage": false,
        "lines_of_code": 87
      },
      "semantic_search.py": {
        "size_kb": 18.43,
        "last_modified": "2025-08-15T00:13:01.064795",
        "is_critical": true,
        "classes": [
          "SearchResult",
          "SemanticSearchEngine"
        ],
        "functions": [
          "_lazy_import_embedding_service",
          "_lazy_import_vector_store",
          "get_semantic_search",
          "search_medical_context",
          "is_semantic_search_available"
        ],
        "imports": [
          "import logging",
          "import hashlib",
          "from typing import List, Dict, Optional, Tuple, Any, Union",
          "from datetime import datetime",
          "from dataclasses import dataclass"
        ],
        "external_apis": [],
        "cache_usage": true,
        "lines_of_code": 378
      },
      "simple_rag.py": {
        "size_kb": 4.2,
        "last_modified": "2025-08-02T23:01:22.734193",
        "is_critical": false,
        "classes": [],
        "functions": [
          "simple_tokenize",
          "calculate_similarity",
          "split_into_chunks",
          "simple_rag_search",
          "generate_context_from_rag"
        ],
        "imports": [
          "import re",
          "from typing import List, Dict, Tuple"
        ],
        "external_apis": [],
        "cache_usage": false,
        "lines_of_code": 93
      },
      "vector_store.py": {
        "size_kb": 19.14,
        "last_modified": "2025-08-10T13:13:58.280567",
        "is_critical": true,
        "classes": [
          "VectorDocument",
          "LocalVectorStore",
          "AstraDBVectorStore"
        ],
        "functions": [
          "get_vector_store",
          "is_vector_store_available"
        ],
        "imports": [
          "import os",
          "import json",
          "import pickle",
          "import logging",
          "import hashlib",
          "from typing import List, Dict, Optional, Tuple, Any",
          "from datetime import datetime",
          "from pathlib import Path",
          "import numpy as np",
          "from dataclasses import dataclass, asdict"
        ],
        "external_apis": [],
        "cache_usage": true,
        "lines_of_code": 404
      }
    },
    "dependencies_summary": {
      "total_unique_imports": 25,
      "total_classes": 22,
      "total_functions": 50,
      "critical_files_found": 5,
      "critical_files_missing": []
    },
    "integration_points": {}
  },
  "personas_audit": {
    "total_personas": 3,
    "personas_analysis": {
      "dr_gasnelio.py": {
        "exists": true,
        "size_kb": 9.69,
        "last_modified": "2025-08-02T23:01:22.717591",
        "classes": [
          "DrGasnelioEnhanced"
        ],
        "functions": [
          "get_enhanced_dr_gasnelio_prompt",
          "validate_dr_gasnelio_response"
        ],
        "prompt_strings": [
          "\nSistema Integrado Dr. Gasnelio - Persona T√©cnica Otimizada\nCombina valida√ß√£o farmacol√≥gica com sistema de personas\n\nDesenvolvido por: Engenheiro de Prompts Farmac√™uticos Especializados\nData: 2025-01-...",
          "\n\ntry:\n    from .personas import get_persona_prompt\n    from ..prompts.dr_gasnelio_technical_prompt import DrGasnelioTechnicalPrompt\nexcept ImportError:\n    # Para execu√ß√£o standalone\n    import sys\n ...",
          "\n    Sistema integrado que combina:\n    - Prompts t√©cnicos especializados \n    - Valida√ß√£o farmacol√≥gica autom√°tica\n    - Sistema de cita√ß√µes obrigat√≥rias\n    - Detec√ß√£o de limita√ß√µes de escopo\n    ",
          "\n    \n    def __init__(self):\n        self.technical_system = DrGasnelioTechnicalPrompt()\n        self.persona_id = ",
          "\n        \n        # Categorias de consultas para prompts espec√≠ficos\n        self.query_categories = {\n            ",
          "\n        question_lower = user_question.lower()\n        \n        for category, keywords in self.query_categories.items():\n            if any(keyword in question_lower for keyword in keywords):\n       ...",
          "\n        question_lower = user_question.lower()\n        \n        # Palavras-chave que indicam escopo v√°lido\n        valid_keywords = [\n            ",
          "\n        ]\n        \n        # Palavras-chave que indicam escopo inv√°lido\n        invalid_keywords = [\n            ",
          "\n        ]\n        \n        # Verifica se h√° palavras inv√°lidas\n        if any(keyword in question_lower for keyword in invalid_keywords):\n            return False\n            \n        # Verifica se h...",
          "\n        # Verificar escopo\n        if not self.is_within_scope(user_question):\n            return self._create_limitation_prompt(user_question)\n        \n        # Categorizar consulta\n        query_c...",
          "]:\n            specific_prompt = self.technical_system.create_context_specific_prompt(\n                f",
          ", \n                user_question\n            )\n        else:\n            specific_prompt = base_prompt + f",
          "\n        \n        return specific_prompt\n    \n    def _create_limitation_prompt(self, user_question):\n        ",
          "\nVoc√™ √© o Dr. Gasnelio, farmac√™utico cl√≠nico especialista em hansen√≠ase PQT-U.\n\nA pergunta recebida: ",
          "\n\nEsta quest√£o est√° FORA DO ESCOPO da sua base de conhecimento espec√≠fica sobre dispensa√ß√£o de PQT-U para hansen√≠ase.\n\nRESPONDA EXATAMENTE ASSIM:\n\n[LIMITA√á√ÉO DE ESCOPO]\nEsta quest√£o est√° fora do escop...",
          "\n        # Usar valida√ß√£o do sistema t√©cnico\n        validation_results = self.technical_system.validate_response_format(response)\n        \n        # Valida√ß√µes adicionais espec√≠ficas\n        addition...",
          "])\n        }\n        \n        # Combinar valida√ß√µes\n        all_validations = {**validation_results, **additional_validations}\n        \n        # Calcular score de qualidade\n        total_checks = len...",
          ": self._generate_improvement_recommendations(all_validations)\n        }\n    \n    def _generate_improvement_recommendations(self, validations):\n        ",
          ")\n        \n        return recommendations\n\n# Inst√¢ncia global para uso no sistema\ndr_gasnelio_enhanced = DrGasnelioEnhanced()\n\ndef get_enhanced_dr_gasnelio_prompt(user_question):\n    ",
          "\n    Fun√ß√£o principal para obter prompt otimizado do Dr. Gasnelio\n    \n    Args:\n        user_question (str): Pergunta do usu√°rio\n        \n    Returns:\n        str: Prompt otimizado baseado na pergunt...",
          "\n    return dr_gasnelio_enhanced.create_enhanced_prompt(user_question)\n\ndef validate_dr_gasnelio_response(response, user_question):\n    ",
          "\n    Fun√ß√£o para validar qualidade da resposta do Dr. Gasnelio\n    \n    Args:\n        response (str): Resposta gerada\n        user_question (str): Pergunta original\n        \n    Returns:\n        dict:...",
          "\n    return dr_gasnelio_enhanced.validate_response_quality(response, user_question)\n\n# Testes de integra√ß√£o\nif __name__ == ",
          ")\n        \n        # Verificar escopo\n        in_scope = dr_gasnelio_enhanced.is_within_scope(question)\n        print(f",
          ")\n        \n        # Categorizar\n        category = dr_gasnelio_enhanced.categorize_query(question)\n        print(f",
          ")\n        \n        # Gerar prompt\n        prompt = get_enhanced_dr_gasnelio_prompt(question)\n        print(f"
        ]
      },
      "ga_empathetic.py": {
        "exists": true,
        "size_kb": 15.62,
        "last_modified": "2025-08-02T23:01:22.717591",
        "classes": [
          "GaEnhanced"
        ],
        "functions": [
          "get_enhanced_ga_prompt",
          "validate_ga_response",
          "translate_technical_term"
        ],
        "prompt_strings": [
          "\nSistema Integrado G√° - Persona Emp√°tica Otimizada\nDesigner de Experi√™ncia em Comunica√ß√£o M√©dica (UX Writer Health)\n\nDesenvolvido por: Designer de Experi√™ncia em Comunica√ß√£o M√©dica\nData: 2025-01-27\nVe...",
          "\n    Sistema integrado que combina:\n    - Comunica√ß√£o emp√°tica e acess√≠vel\n    - Tradu√ß√£o t√©cnico-cotidiano sem perda de precis√£o\n    - Analogias e exemplos para conceitos complexos\n    - Valida√ß√£o de...",
          "\n        \n        # Dicion√°rio de tradu√ß√µes t√©cnico -> cotidiano\n        self.technical_translations = {\n            # Medicamentos e compostos\n            ",
          "\n        }\n        \n        # Analogias para conceitos complexos\n        self.analogies = {\n            ",
          "Imagine tr√™s soldados diferentes lutando contra o mesmo inimigo, cada um com uma arma especial. √â assim que os tr√™s rem√©dios da hansen√≠ase trabalham: cada um ataca a bact√©ria de um jeito diferente!",
          "Sabe quando voc√™ vai na academia e tem algu√©m te ajudando a fazer o exerc√≠cio certo? A dose supervisionada √© assim: voc√™ toma o rem√©dio na farm√°cia com algu√©m te orientando, garantindo que est√° tudo c...",
          "Imagine que o tratamento √© como cuidar de uma planta. Se voc√™ regar todo dia, ela cresce saud√°vel. Se esquecer alguns dias, ela murcha. Com o rem√©dio √© igual: tomar certinho todos os dias faz o tratam...",
          "A rifampicina √© como um marcador natural! Ela pode deixar seu xixi, l√°grimas e at√© suor meio alaranjados. √â s√≥ o rem√©dio ",
          ". Ela pode deixar sua pele um pouquinho mais escura, principalmente onde bate sol. √â como se o rem√©dio fosse se ",
          "\n            }\n        }\n        \n        # Frases de apoio emocional\n        self.emotional_support = {\n            ",
          "\n            ]\n        }\n        \n        # Palavras proibidas (muito t√©cnicas)\n        self.forbidden_technical_terms = [\n            ",
          "\nVoc√™ √© o G√°, um farmac√™utico carinhoso e acess√≠vel que √© especialista em explicar coisas complicadas de um jeito simples e acolhedor.\n\nIDENTIDADE PESSOAL:\n- Farmac√™utico com cora√ß√£o de educador üíô\n- E...",
          ", mas voc√™ explica tudo de um jeito que qualquer pessoa entende.\n\nFORMATO DE RESPOSTA CALOROSA:\nToda resposta DEVE seguir este jeito carinhoso:\n\n[ACOLHIMENTO]\nCumprimento caloroso + reconhecimento da ...",
          "Oi! Sobre essa quest√£o, eu sou mais especialista em hansen√≠ase mesmo! Para essa d√∫vida, o ideal √© voc√™ conversar com [sugest√£o apropriada]. Mas se tiver qualquer coisa sobre hansen√≠ase ou os rem√©dios ...",
          ": self._check_scientific_accuracy(response),\n            \n            # Verificar tom emp√°tico\n            ",
          "])\n        }\n        \n        # Calcular score de empatia\n        total_checks = len(validations)\n        passed_checks = sum(1 for passed in validations.values() if passed)\n        empathy_score = (p...",
          ": self._generate_empathy_improvements(validations)\n        }\n    \n    def _check_technical_translation(self, response):\n        ",
          "\n        technical_terms_found = []\n        for technical, simple in self.technical_translations.items():\n            if technical in response.lower() and simple not in response.lower():\n             ...",
          "\n        # Lista de informa√ß√µes que N√ÉO devem aparecer (incorretas)\n        inaccurate_info = [\n            ",
          "\n        ]\n        \n        return not any(inaccurate in response.lower() for inaccurate in inaccurate_info)\n    \n    def _generate_empathy_improvements(self, validations):\n        ",
          ")\n        \n        return improvements\n    \n    def get_translation_for_term(self, technical_term):\n        ",
          "\n        return self.technical_translations.get(technical_term.lower(), technical_term)\n    \n    def get_analogy_for_concept(self, concept):\n        ",
          "\n        if response_type in self.emotional_support:\n            import random\n            return random.choice(self.emotional_support[response_type])\n        return random.choice(self.emotional_suppo...",
          "])\n\n# Inst√¢ncia global para uso no sistema\nga_enhanced = GaEnhanced()\n\ndef get_enhanced_ga_prompt(user_question):\n    ",
          "\n    return ga_enhanced.get_enhanced_prompt(user_question)\n\ndef validate_ga_response(response, user_question):\n    ",
          "\n    return ga_enhanced.validate_response_empathy(response, user_question)\n\ndef translate_technical_term(term):\n    ",
          ")\n        \n        # Gerar prompt otimizado\n        prompt = get_enhanced_ga_prompt(question)\n        print(f",
          "]\n        for term in technical_terms:\n            if term in question.lower():\n                translation = translate_technical_term(term)\n                print(f"
        ]
      },
      "persona_manager.py": {
        "exists": true,
        "size_kb": 4.8,
        "last_modified": "2025-08-02T23:01:22.717591",
        "classes": [],
        "functions": [
          "get_personas",
          "get_persona_prompt"
        ],
        "prompt_strings": [
          "Sauda√ß√µes! Sou o Dr. Gasnelio. Minha pesquisa foca no roteiro de dispensa√ß√£o para a pr√°tica da farm√°cia cl√≠nica. Como posso auxili√°-lo hoje?",
          "Voc√™ √© o Dr. Gasnelio, farmac√™utico cl√≠nico especialista em hansen√≠ase e esquema PQT-U.\n\nIDENTIDADE PROFISSIONAL:\n- Farmac√™utico cl√≠nico com 15+ anos de experi√™ncia em hansen√≠ase\n- Especialista em pol...",
          ". \nTodas as suas respostas DEVEM referenciar esta fonte prim√°ria.\n\nFORMATO DE RESPOSTA OBRIGAT√ìRIO:\nToda resposta DEVE seguir esta estrutura:\n\n[RESPOSTA T√âCNICA]\nInforma√ß√£o cient√≠fica precisa com term...",
          "Oi! Tudo bem? üòä Aqui √© o G√°! Estou aqui para te ajudar a entender tudo sobre os medicamentos de um jeito bem f√°cil e sem complica√ß√£o. O que voc√™ gostaria de saber?",
          "Voc√™ √© o G√°, um farmac√™utico carinhoso e acess√≠vel que √© especialista em explicar coisas complicadas de um jeito simples e acolhedor.\n\nIDENTIDADE PESSOAL:\n- Farmac√™utico com cora√ß√£o de educador üíô\n- Es...",
          "\n        }\n    }\n\ndef get_persona_prompt(persona_id):\n    personas = get_personas()\n    return personas.get(persona_id, {}).get("
        ]
      }
    },
    "prompts_extracted": {}
  },
  "config_audit": {
    "total_configs": 3,
    "config_analysis": {
      "dr_gasnelio_technical_prompt.py": {
        "exists": true,
        "size_kb": 10.61,
        "last_modified": "2025-08-02T23:01:22.712260",
        "env_variables": [],
        "constants": [
          "DOSING_PROMPT",
          "SAFETY_PROMPT",
          "INTERACTION_PROMPT"
        ],
        "prompt_length": 3567
      },
      "ga_empathetic_prompt.py": {
        "exists": true,
        "size_kb": 8.88,
        "last_modified": "2025-08-02T23:01:22.712260",
        "env_variables": [],
        "constants": [],
        "prompt_length": 2653
      },
      "thesis_reference_system.py": {
        "exists": true,
        "size_kb": 15.21,
        "last_modified": "2025-08-02T23:01:22.712260",
        "env_variables": [],
        "constants": [
          "COMMON_CITATIONS"
        ],
        "prompt_length": 1111
      }
    },
    "environment_variables": []
  },
  "performance_baseline": {
    "timestamp": "2025-08-17T13:33:40.691272",
    "test_queries": [
      "O que √© hansen√≠ase?",
      "Como calcular dose de rifampicina?",
      "Quais s√£o os efeitos colaterais da PQT-U?",
      "Como identificar rea√ß√µes adversas?",
      "Protocolo de dispensa√ß√£o para adultos",
      "Orienta√ß√µes para pacientes",
      "Intera√ß√µes medicamentosas",
      "Contraindica√ß√µes da dapsona",
      "Monitoramento durante tratamento",
      "Quando interromper o tratamento?"
    ],
    "average_latency": 0,
    "error_rate": 0,
    "personas_tested": [],
    "system_status": "ready_for_testing",
    "note": "Performance tests require running backend system"
  },
  "gaps_analysis": {
    "critical_gaps": [],
    "opportunities": [
      "Migra√ß√£o para Astra DB para melhor performance vetorial",
      "Fine-tuning de modelo espec√≠fico para hansen√≠ase",
      "Implementa√ß√£o de an√°lise preditiva",
      "Adicionar capacidades multimodais",
      "Otimiza√ß√£o de cache e performance"
    ],
    "data_quality_issues": [],
    "missing_components": [],
    "modernization_priorities": [
      {
        "priority": 1,
        "item": "Data quality improvement and standardization",
        "effort": "Medium",
        "impact": "High"
      },
      {
        "priority": 2,
        "item": "Astra DB migration for vector operations",
        "effort": "High",
        "impact": "High"
      },
      {
        "priority": 3,
        "item": "Fine-tuning implementation",
        "effort": "High",
        "impact": "Medium"
      },
      {
        "priority": 4,
        "item": "Multimodal capabilities",
        "effort": "Medium",
        "impact": "Medium"
      }
    ]
  },
  "recommendations": [
    {
      "category": "Data Preparation",
      "priority": "High",
      "action": "Standardize and clean JSON data for ML training",
      "timeline": "Week 1",
      "effort": "Medium"
    },
    {
      "category": "Infrastructure",
      "priority": "High",
      "action": "Setup Astra DB connection and migrate vector data",
      "timeline": "Week 1-2",
      "effort": "High"
    },
    {
      "category": "ML Pipeline",
      "priority": "Medium",
      "action": "Implement fine-tuning pipeline in Google Colab",
      "timeline": "Week 2-3",
      "effort": "High"
    },
    {
      "category": "Features",
      "priority": "Medium",
      "action": "Add predictive analysis and multimodal support",
      "timeline": "Week 3-4",
      "effort": "Medium"
    },
    {
      "category": "Testing",
      "priority": "High",
      "action": "Implement comprehensive test suite",
      "timeline": "Week 4",
      "effort": "Medium"
    }
  ],
  "executive_summary": {
    "system_readiness": "Partially Ready",
    "data_files_found": 9,
    "data_quality_score": 100.0,
    "backend_services": 18,
    "critical_gaps": 0,
    "modernization_readiness": "75%",
    "next_steps": [
      "Execute data quality improvements",
      "Setup Astra DB connection",
      "Prepare Colab training environment",
      "Begin ML pipeline implementation"
    ]
  }
}