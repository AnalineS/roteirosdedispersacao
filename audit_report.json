{
  "audit_metadata": {
    "timestamp": "2025-08-17T13:33:40.628007",
    "version": "Q2-2025-ML-MODERNIZATION",
    "auditor": "Claude Code Assistant",
    "base_path": "C:\\Users\\Ana\\Meu Drive\\Site roteiro de dispensação",
    "duration_seconds": 0.06,
    "completion_time": "2025-08-17T13:33:40.691283"
  },
  "data_audit": {
    "total_files": 9,
    "total_size_mb": 0.09229850769042969,
    "files_analysis": {
      "clinical_taxonomy.json": {
        "size_mb": 0.011,
        "size_bytes": 11947,
        "last_modified": "2025-07-27T12:36:30.281189",
        "structure_type": "dict",
        "total_entries": 1,
        "estimated_tokens": 2044,
        "completeness_score": 100.0,
        "unique_fields": [
          "clinical_taxonomy"
        ],
        "missing_required_fields": [],
        "is_target_file": true
      },
      "dispensing_workflow.json": {
        "size_mb": 0.011,
        "size_bytes": 11583,
        "last_modified": "2025-07-27T12:32:54.292425",
        "structure_type": "dict",
        "total_entries": 4,
        "estimated_tokens": 1983,
        "completeness_score": 100.0,
        "unique_fields": [
          "dispensing_workflow",
          "quality_indicators",
          "workflow_optimization",
          "emergency_protocols"
        ],
        "missing_required_fields": [],
        "is_target_file": true
      },
      "dosing_protocols.json": {
        "size_mb": 0.007,
        "size_bytes": 7440,
        "last_modified": "2025-07-27T12:29:46.791105",
        "structure_type": "dict",
        "total_entries": 5,
        "estimated_tokens": 1289,
        "completeness_score": 100.0,
        "unique_fields": [
          "dosing_protocols",
          "administration_guidelines",
          "dispensing_schedule",
          "monitoring_schedule",
          "quality_assurance"
        ],
        "missing_required_fields": [],
        "is_target_file": true
      },
      "frequently_asked_questions.json": {
        "size_mb": 0.014,
        "size_bytes": 14446,
        "last_modified": "2025-07-27T12:41:21.824784",
        "structure_type": "dict",
        "total_entries": 1,
        "estimated_tokens": 3141,
        "completeness_score": 100.0,
        "unique_fields": [
          "faq_hanseniase_pqtu"
        ],
        "missing_required_fields": [],
        "is_target_file": true
      },
      "hanseniase_catalog.json": {
        "size_mb": 0.008,
        "size_bytes": 8100,
        "last_modified": "2025-07-27T12:28:47.393565",
        "structure_type": "dict",
        "total_entries": 6,
        "estimated_tokens": 1581,
        "completeness_score": 100.0,
        "unique_fields": [
          "document_info",
          "clinical_presentations",
          "medications",
          "dispensing_protocol",
          "safety_profile",
          "clinical_references"
        ],
        "missing_required_fields": [],
        "is_target_file": true
      },
      "knowledge_scope_limitations.json": {
        "size_mb": 0.01,
        "size_bytes": 10364,
        "last_modified": "2025-07-27T12:42:34.625339",
        "structure_type": "dict",
        "total_entries": 1,
        "estimated_tokens": 1794,
        "completeness_score": 100.0,
        "unique_fields": [
          "knowledge_scope_limitations"
        ],
        "missing_required_fields": [],
        "is_target_file": true
      },
      "medications_mechanisms.json": {
        "size_mb": 0.01,
        "size_bytes": 10356,
        "last_modified": "2025-07-27T12:31:19.408155",
        "structure_type": "dict",
        "total_entries": 3,
        "estimated_tokens": 1869,
        "completeness_score": 100.0,
        "unique_fields": [
          "medications",
          "combination_rationale",
          "therapeutic_monitoring"
        ],
        "missing_required_fields": [],
        "is_target_file": true
      },
      "pharmacovigilance_guidelines.json": {
        "size_mb": 0.011,
        "size_bytes": 11355,
        "last_modified": "2025-07-27T12:34:19.012701",
        "structure_type": "dict",
        "total_entries": 1,
        "estimated_tokens": 1902,
        "completeness_score": 100.0,
        "unique_fields": [
          "pharmacovigilance_guidelines"
        ],
        "missing_required_fields": [],
        "is_target_file": true
      },
      "quick_reference_protocols.json": {
        "size_mb": 0.011,
        "size_bytes": 11191,
        "last_modified": "2025-07-27T12:39:20.604365",
        "structure_type": "dict",
        "total_entries": 1,
        "estimated_tokens": 2022,
        "completeness_score": 100.0,
        "unique_fields": [
          "quick_reference_protocols"
        ],
        "missing_required_fields": [],
        "is_target_file": true
      }
    },
    "schema_validation": {},
    "data_quality_score": 100.0,
    "total_estimated_tokens": 17625,
    "target_files_found": 9,
    "target_files_missing": []
  },
  "documents_audit": {
    "total_documents": 3,
    "documents_analysis": {
      "Roteiro de Dsispensação - Hanseníase.md": {
        "exists": true,
        "size_mb": 0.011,
        "size_bytes": 11861,
        "last_modified": "2025-07-24T22:49:45.844033",
        "extension": ".md",
        "total_lines": 277,
        "total_characters": 11208,
        "estimated_tokens": 2802,
        "structure": {
          "total_headers": 22,
          "header_levels": {
            "1": 2,
            "2": 7,
            "3": 9,
            "4": 4
          },
          "topics": [
            {
              "level": 1,
              "title": "ROTEIRO PARA DISPENSAÇÃO – HANSENÍASE (PQT-U)"
            },
            {
              "level": 2,
              "title": "APRESENTAÇÕES DISPONÍVEIS (Fontes: 1–3):"
            },
            {
              "level": 2,
              "title": "ETAPA 01 – AVALIAÇÃO INICIAL"
            },
            {
              "level": 2,
              "title": "ETAPA 02 – ORIENTAÇÕES E PLANO DE CUIDADO"
            },
            {
              "level": 3,
              "title": "INDICAÇÕES (Fontes: 2, 7–9)"
            },
            {
              "level": 3,
              "title": "EFICÁCIA E MODO DE USO (2, 7)"
            },
            {
              "level": 4,
              "title": "PARA ADULTOS (> 50 kg)"
            },
            {
              "level": 4,
              "title": "PARA CRIANÇAS ou ADULTOS (30 a 50 kg)"
            },
            {
              "level": 4,
              "title": "PARA CRIANÇAS < 30 kg"
            },
            {
              "level": 3,
              "title": "NÃO FARMACOLÓGICAS (2, 9)"
            },
            {
              "level": 3,
              "title": "ARMAZENAMENTO E DESCARTE (13)"
            },
            {
              "level": 2,
              "title": "SEGURANÇA"
            },
            {
              "level": 2,
              "title": "POPULAÇÕES ESPECIAIS"
            },
            {
              "level": 2,
              "title": "ETAPA 03 – PÓS-DISPENSAÇÃO E AVALIAÇÃO"
            },
            {
              "level": 4,
              "title": "ORIENTAÇÕES/INTERVENÇÕES ESSENCIAIS (2, 9):"
            },
            {
              "level": 3,
              "title": "EVENTOS ADVERSOS MAIS COMUNS (ANVISA – 14):"
            },
            {
              "level": 3,
              "title": "EM CADA DISPENSAÇÃO (2, 9):"
            },
            {
              "level": 1,
              "title": "BLOCO CLOFAZIMINA"
            },
            {
              "level": 3,
              "title": "APRESENTAÇÃO (1–3)"
            },
            {
              "level": 3,
              "title": "INDICAÇÕES (2, 7, 17)"
            },
            {
              "level": 3,
              "title": "MODO DE USO (2, 10, 17, 18)"
            },
            {
              "level": 2,
              "title": "CITAS/FONTES DO DOCUMENTO"
            }
          ]
        }
      },
      "Roteiro de Dsispensação - Hanseníase.pdf": {
        "exists": true,
        "size_mb": 0.965,
        "size_bytes": 1012182,
        "last_modified": "2025-07-13T10:37:05.159144",
        "extension": ".pdf",
        "note": "PDF analysis requires external libraries"
      },
      "roteiro_hanseniase_basico.md": {
        "exists": true,
        "size_mb": 0.001,
        "size_bytes": 1457,
        "last_modified": "2025-07-27T10:49:14.170970",
        "extension": ".md",
        "total_lines": 52,
        "total_characters": 1364,
        "estimated_tokens": 341,
        "structure": {
          "total_headers": 10,
          "header_levels": {
            "1": 1,
            "2": 1,
            "3": 3,
            "4": 5
          },
          "topics": [
            {
              "level": 1,
              "title": "Roteiro de Dispensação para Hanseníase"
            },
            {
              "level": 2,
              "title": "Sobre a Hanseníase"
            },
            {
              "level": 3,
              "title": "Tratamento PQT-U (Poliquimioterapia Única)"
            },
            {
              "level": 4,
              "title": "Esquema Adulto:"
            },
            {
              "level": 4,
              "title": "Esquema Infantil:"
            },
            {
              "level": 3,
              "title": "Orientações de Dispensação"
            },
            {
              "level": 3,
              "title": "Medicamentos"
            },
            {
              "level": 4,
              "title": "Rifampicina"
            },
            {
              "level": 4,
              "title": "Dapsona"
            },
            {
              "level": 4,
              "title": "Clofazimina"
            }
          ]
        }
      }
    },
    "content_structure": {}
  },
  "backend_services_audit": {
    "total_services": 18,
    "services_analysis": {
      "advanced_cache.py": {
        "size_kb": 6.93,
        "last_modified": "2025-08-02T23:01:22.733046",
        "is_critical": false,
        "classes": [
          "PerformanceCache"
        ],
        "functions": [],
        "imports": [
          "import time",
          "import json",
          "import hashlib",
          "from datetime import datetime, timedelta",
          "from collections import OrderedDict",
          "import threading",
          "import logging"
        ],
        "external_apis": [],
        "cache_usage": true,
        "lines_of_code": 157
      },
      "ai_provider_manager.py": {
        "size_kb": 19.97,
        "last_modified": "2025-08-10T11:56:36.331477",
        "is_critical": false,
        "classes": [
          "ProviderStatus",
          "CircuitBreakerState",
          "CircuitBreaker",
          "ModelConfig",
          "AIProviderManager"
        ],
        "functions": [
          "get_ai_health_status"
        ],
        "imports": [
          "import os",
          "import time",
          "import logging",
          "import asyncio",
          "from typing import Dict, List, Optional, Union, Tuple",
          "from datetime import datetime, timedelta",
          "from dataclasses import dataclass",
          "from enum import Enum",
          "import requests"
        ],
        "external_apis": [
          "api_key",
          "endpoint",
          "requests"
        ],
        "cache_usage": false,
        "lines_of_code": 406
      },
      "chatbot.py": {
        "size_kb": 18.2,
        "last_modified": "2025-08-16T01:02:00.181840",
        "is_critical": false,
        "classes": [
          "ChatbotService"
        ],
        "functions": [
          "create_chatbot_service"
        ],
        "imports": [
          "import os",
          "import json",
          "import logging",
          "from typing import Dict, List, Optional, Tuple",
          "from datetime import datetime",
          "import requests",
          "from pathlib import Path",
          "import numpy as np",
          "from sklearn.feature_extraction.text import TfidfVectorizer",
          "from sklearn.metrics.pairwise import cosine_similarity",
          "from ..config.personas import get_persona_by_id",
          "from ..core.security.medical_audit_logger import ("
        ],
        "external_apis": [
          "api_key",
          "requests"
        ],
        "cache_usage": true,
        "lines_of_code": 304
      },
      "dr_gasnelio_enhanced.py": {
        "size_kb": 2.01,
        "last_modified": "2025-08-02T23:01:22.734193",
        "is_critical": false,
        "classes": [],
        "functions": [
          "get_enhanced_dr_gasnelio_prompt",
          "validate_dr_gasnelio_response"
        ],
        "imports": [],
        "external_apis": [],
        "cache_usage": false,
        "lines_of_code": 44
      },
      "embeddings_api.py": {
        "size_kb": 3.45,
        "last_modified": "2025-08-13T19:53:25.962026",
        "is_critical": false,
        "classes": [
          "HuggingFaceEmbeddings"
        ],
        "functions": [
          "get_text_embedding",
          "get_batch_embeddings"
        ],
        "imports": [
          "import os",
          "import requests",
          "import logging",
          "from typing import List, Optional",
          "from cachetools import TTLCache"
        ],
        "external_apis": [
          "api_key",
          "requests"
        ],
        "cache_usage": true,
        "lines_of_code": 70
      },
      "embedding_rag_system.py": {
        "size_kb": 14.56,
        "last_modified": "2025-08-10T13:33:42.706773",
        "is_critical": false,
        "classes": [
          "EmbeddingRAGSystem"
        ],
        "functions": [
          "get_embedding_rag",
          "get_rag_context"
        ],
        "imports": [
          "import logging",
          "from typing import List, Dict, Optional, Tuple, Any",
          "from datetime import datetime",
          "import os",
          "from services.semantic_search import get_semantic_search, SearchResult",
          "from services.medical_chunking import MedicalChunk, MedicalChunker"
        ],
        "external_apis": [],
        "cache_usage": true,
        "lines_of_code": 290
      },
      "embedding_service.py": {
        "size_kb": 27.18,
        "last_modified": "2025-08-14T23:40:35.132731",
        "is_critical": true,
        "classes": [
          "EmbeddingCache",
          "EmbeddingService"
        ],
        "functions": [
          "_test_sentence_transformers",
          "_lazy_import_sentence_transformers",
          "get_embedding_service",
          "is_embeddings_available",
          "get_embedding_stats",
          "embed_text",
          "embed_texts_batch",
          "test_embeddings_system",
          "embed_texts"
        ],
        "imports": [
          "import os",
          "import pickle",
          "import logging",
          "import hashlib",
          "from typing import List, Dict, Optional, Tuple, Any, Union",
          "from datetime import datetime, timedelta",
          "from pathlib import Path",
          "import threading"
        ],
        "external_apis": [],
        "cache_usage": true,
        "lines_of_code": 544
      },
      "enhanced_rag_system.py": {
        "size_kb": 5.53,
        "last_modified": "2025-08-02T23:01:22.734193",
        "is_critical": true,
        "classes": [
          "EnhancedRAGSystem"
        ],
        "functions": [
          "get_enhanced_context",
          "cache_rag_response",
          "add_rag_feedback",
          "get_rag_stats"
        ],
        "imports": [
          "from typing import Dict, List, Optional",
          "from datetime import datetime",
          "from collections import defaultdict",
          "import json",
          "import re"
        ],
        "external_apis": [
          "requests"
        ],
        "cache_usage": true,
        "lines_of_code": 112
      },
      "ga_enhanced.py": {
        "size_kb": 2.54,
        "last_modified": "2025-08-02T23:01:22.734193",
        "is_critical": false,
        "classes": [],
        "functions": [
          "get_enhanced_ga_prompt",
          "validate_ga_response"
        ],
        "imports": [],
        "external_apis": [],
        "cache_usage": false,
        "lines_of_code": 57
      },
      "knowledge_loader.py": {
        "size_kb": 13.84,
        "last_modified": "2025-08-02T23:01:22.734193",
        "is_critical": false,
        "classes": [
          "StructuredKnowledgeBase"
        ],
        "functions": [
          "get_structured_knowledge_base"
        ],
        "imports": [
          "import json",
          "import os",
          "import logging",
          "from typing import Dict, List, Any"
        ],
        "external_apis": [],
        "cache_usage": false,
        "lines_of_code": 223
      },
      "medical_chunking.py": {
        "size_kb": 18.59,
        "last_modified": "2025-08-10T10:23:35.834057",
        "is_critical": false,
        "classes": [
          "ChunkPriority",
          "MedicalChunk",
          "MedicalChunker"
        ],
        "functions": [
          "chunk_medical_text",
          "chunk_medical_document",
          "process_medical_table"
        ],
        "imports": [
          "import re",
          "from typing import List, Dict, Any, Tuple, Optional",
          "from dataclasses import dataclass",
          "from enum import Enum",
          "import logging",
          "from app_config import config"
        ],
        "external_apis": [],
        "cache_usage": false,
        "lines_of_code": 337
      },
      "medical_rag_integration.py": {
        "size_kb": 11.96,
        "last_modified": "2025-08-10T16:42:47.123915",
        "is_critical": true,
        "classes": [
          "MedicalRAGSystem"
        ],
        "functions": [
          "get_medical_context",
          "get_medical_stats",
          "reload_medical_knowledge"
        ],
        "imports": [
          "import os",
          "import json",
          "from typing import List, Dict, Tuple, Optional",
          "from dataclasses import asdict",
          "import logging",
          "from services.medical_chunking import medical_chunker, MedicalChunk, chunk_medical_document",
          "from app_config import config"
        ],
        "external_apis": [],
        "cache_usage": false,
        "lines_of_code": 217
      },
      "openai_integration.py": {
        "size_kb": 2.44,
        "last_modified": "2025-08-02T23:01:22.734193",
        "is_critical": false,
        "classes": [],
        "functions": [
          "test_openai_connection",
          "get_ai_response_mock"
        ],
        "imports": [
          "import os",
          "import logging"
        ],
        "external_apis": [
          "openai",
          "api_key"
        ],
        "cache_usage": false,
        "lines_of_code": 53
      },
      "personas.py": {
        "size_kb": 2.8,
        "last_modified": "2025-08-02T23:01:22.734193",
        "is_critical": false,
        "classes": [],
        "functions": [
          "get_personas",
          "get_persona_prompt",
          "validate_persona",
          "get_persona_capabilities"
        ],
        "imports": [],
        "external_apis": [],
        "cache_usage": false,
        "lines_of_code": 62
      },
      "scope_detection_system.py": {
        "size_kb": 4.42,
        "last_modified": "2025-08-02T23:01:22.734193",
        "is_critical": false,
        "classes": [],
        "functions": [
          "detect_question_scope",
          "get_limitation_response"
        ],
        "imports": [
          "import re",
          "from typing import Dict, List"
        ],
        "external_apis": [],
        "cache_usage": false,
        "lines_of_code": 87
      },
      "semantic_search.py": {
        "size_kb": 18.43,
        "last_modified": "2025-08-15T00:13:01.064795",
        "is_critical": true,
        "classes": [
          "SearchResult",
          "SemanticSearchEngine"
        ],
        "functions": [
          "_lazy_import_embedding_service",
          "_lazy_import_vector_store",
          "get_semantic_search",
          "search_medical_context",
          "is_semantic_search_available"
        ],
        "imports": [
          "import logging",
          "import hashlib",
          "from typing import List, Dict, Optional, Tuple, Any, Union",
          "from datetime import datetime",
          "from dataclasses import dataclass"
        ],
        "external_apis": [],
        "cache_usage": true,
        "lines_of_code": 378
      },
      "simple_rag.py": {
        "size_kb": 4.2,
        "last_modified": "2025-08-02T23:01:22.734193",
        "is_critical": false,
        "classes": [],
        "functions": [
          "simple_tokenize",
          "calculate_similarity",
          "split_into_chunks",
          "simple_rag_search",
          "generate_context_from_rag"
        ],
        "imports": [
          "import re",
          "from typing import List, Dict, Tuple"
        ],
        "external_apis": [],
        "cache_usage": false,
        "lines_of_code": 93
      },
      "vector_store.py": {
        "size_kb": 19.14,
        "last_modified": "2025-08-10T13:13:58.280567",
        "is_critical": true,
        "classes": [
          "VectorDocument",
          "LocalVectorStore",
          "AstraDBVectorStore"
        ],
        "functions": [
          "get_vector_store",
          "is_vector_store_available"
        ],
        "imports": [
          "import os",
          "import json",
          "import pickle",
          "import logging",
          "import hashlib",
          "from typing import List, Dict, Optional, Tuple, Any",
          "from datetime import datetime",
          "from pathlib import Path",
          "import numpy as np",
          "from dataclasses import dataclass, asdict"
        ],
        "external_apis": [],
        "cache_usage": true,
        "lines_of_code": 404
      }
    },
    "dependencies_summary": {
      "total_unique_imports": 25,
      "total_classes": 22,
      "total_functions": 50,
      "critical_files_found": 5,
      "critical_files_missing": []
    },
    "integration_points": {}
  },
  "personas_audit": {
    "total_personas": 3,
    "personas_analysis": {
      "dr_gasnelio.py": {
        "exists": true,
        "size_kb": 9.69,
        "last_modified": "2025-08-02T23:01:22.717591",
        "classes": [
          "DrGasnelioEnhanced"
        ],
        "functions": [
          "get_enhanced_dr_gasnelio_prompt",
          "validate_dr_gasnelio_response"
        ],
        "prompt_strings": [
          "\nSistema Integrado Dr. Gasnelio - Persona Técnica Otimizada\nCombina validação farmacológica com sistema de personas\n\nDesenvolvido por: Engenheiro de Prompts Farmacêuticos Especializados\nData: 2025-01-...",
          "\n\ntry:\n    from .personas import get_persona_prompt\n    from ..prompts.dr_gasnelio_technical_prompt import DrGasnelioTechnicalPrompt\nexcept ImportError:\n    # Para execução standalone\n    import sys\n ...",
          "\n    Sistema integrado que combina:\n    - Prompts técnicos especializados \n    - Validação farmacológica automática\n    - Sistema de citações obrigatórias\n    - Detecção de limitações de escopo\n    ",
          "\n    \n    def __init__(self):\n        self.technical_system = DrGasnelioTechnicalPrompt()\n        self.persona_id = ",
          "\n        \n        # Categorias de consultas para prompts específicos\n        self.query_categories = {\n            ",
          "\n        question_lower = user_question.lower()\n        \n        for category, keywords in self.query_categories.items():\n            if any(keyword in question_lower for keyword in keywords):\n       ...",
          "\n        question_lower = user_question.lower()\n        \n        # Palavras-chave que indicam escopo válido\n        valid_keywords = [\n            ",
          "\n        ]\n        \n        # Palavras-chave que indicam escopo inválido\n        invalid_keywords = [\n            ",
          "\n        ]\n        \n        # Verifica se há palavras inválidas\n        if any(keyword in question_lower for keyword in invalid_keywords):\n            return False\n            \n        # Verifica se h...",
          "\n        # Verificar escopo\n        if not self.is_within_scope(user_question):\n            return self._create_limitation_prompt(user_question)\n        \n        # Categorizar consulta\n        query_c...",
          "]:\n            specific_prompt = self.technical_system.create_context_specific_prompt(\n                f",
          ", \n                user_question\n            )\n        else:\n            specific_prompt = base_prompt + f",
          "\n        \n        return specific_prompt\n    \n    def _create_limitation_prompt(self, user_question):\n        ",
          "\nVocê é o Dr. Gasnelio, farmacêutico clínico especialista em hanseníase PQT-U.\n\nA pergunta recebida: ",
          "\n\nEsta questão está FORA DO ESCOPO da sua base de conhecimento específica sobre dispensação de PQT-U para hanseníase.\n\nRESPONDA EXATAMENTE ASSIM:\n\n[LIMITAÇÃO DE ESCOPO]\nEsta questão está fora do escop...",
          "\n        # Usar validação do sistema técnico\n        validation_results = self.technical_system.validate_response_format(response)\n        \n        # Validações adicionais específicas\n        addition...",
          "])\n        }\n        \n        # Combinar validações\n        all_validations = {**validation_results, **additional_validations}\n        \n        # Calcular score de qualidade\n        total_checks = len...",
          ": self._generate_improvement_recommendations(all_validations)\n        }\n    \n    def _generate_improvement_recommendations(self, validations):\n        ",
          ")\n        \n        return recommendations\n\n# Instância global para uso no sistema\ndr_gasnelio_enhanced = DrGasnelioEnhanced()\n\ndef get_enhanced_dr_gasnelio_prompt(user_question):\n    ",
          "\n    Função principal para obter prompt otimizado do Dr. Gasnelio\n    \n    Args:\n        user_question (str): Pergunta do usuário\n        \n    Returns:\n        str: Prompt otimizado baseado na pergunt...",
          "\n    return dr_gasnelio_enhanced.create_enhanced_prompt(user_question)\n\ndef validate_dr_gasnelio_response(response, user_question):\n    ",
          "\n    Função para validar qualidade da resposta do Dr. Gasnelio\n    \n    Args:\n        response (str): Resposta gerada\n        user_question (str): Pergunta original\n        \n    Returns:\n        dict:...",
          "\n    return dr_gasnelio_enhanced.validate_response_quality(response, user_question)\n\n# Testes de integração\nif __name__ == ",
          ")\n        \n        # Verificar escopo\n        in_scope = dr_gasnelio_enhanced.is_within_scope(question)\n        print(f",
          ")\n        \n        # Categorizar\n        category = dr_gasnelio_enhanced.categorize_query(question)\n        print(f",
          ")\n        \n        # Gerar prompt\n        prompt = get_enhanced_dr_gasnelio_prompt(question)\n        print(f"
        ]
      },
      "ga_empathetic.py": {
        "exists": true,
        "size_kb": 15.62,
        "last_modified": "2025-08-02T23:01:22.717591",
        "classes": [
          "GaEnhanced"
        ],
        "functions": [
          "get_enhanced_ga_prompt",
          "validate_ga_response",
          "translate_technical_term"
        ],
        "prompt_strings": [
          "\nSistema Integrado Gá - Persona Empática Otimizada\nDesigner de Experiência em Comunicação Médica (UX Writer Health)\n\nDesenvolvido por: Designer de Experiência em Comunicação Médica\nData: 2025-01-27\nVe...",
          "\n    Sistema integrado que combina:\n    - Comunicação empática e acessível\n    - Tradução técnico-cotidiano sem perda de precisão\n    - Analogias e exemplos para conceitos complexos\n    - Validação de...",
          "\n        \n        # Dicionário de traduções técnico → cotidiano\n        self.technical_translations = {\n            # Medicamentos e compostos\n            ",
          "\n        }\n        \n        # Analogias para conceitos complexos\n        self.analogies = {\n            ",
          "Imagine três soldados diferentes lutando contra o mesmo inimigo, cada um com uma arma especial. É assim que os três remédios da hanseníase trabalham: cada um ataca a bactéria de um jeito diferente!",
          "Sabe quando você vai na academia e tem alguém te ajudando a fazer o exercício certo? A dose supervisionada é assim: você toma o remédio na farmácia com alguém te orientando, garantindo que está tudo c...",
          "Imagine que o tratamento é como cuidar de uma planta. Se você regar todo dia, ela cresce saudável. Se esquecer alguns dias, ela murcha. Com o remédio é igual: tomar certinho todos os dias faz o tratam...",
          "A rifampicina é como um marcador natural! Ela pode deixar seu xixi, lágrimas e até suor meio alaranjados. É só o remédio ",
          ". Ela pode deixar sua pele um pouquinho mais escura, principalmente onde bate sol. É como se o remédio fosse se ",
          "\n            }\n        }\n        \n        # Frases de apoio emocional\n        self.emotional_support = {\n            ",
          "\n            ]\n        }\n        \n        # Palavras proibidas (muito técnicas)\n        self.forbidden_technical_terms = [\n            ",
          "\nVocê é o Gá, um farmacêutico carinhoso e acessível que é especialista em explicar coisas complicadas de um jeito simples e acolhedor.\n\nIDENTIDADE PESSOAL:\n- Farmacêutico com coração de educador 💙\n- E...",
          ", mas você explica tudo de um jeito que qualquer pessoa entende.\n\nFORMATO DE RESPOSTA CALOROSA:\nToda resposta DEVE seguir este jeito carinhoso:\n\n[ACOLHIMENTO]\nCumprimento caloroso + reconhecimento da ...",
          "Oi! Sobre essa questão, eu sou mais especialista em hanseníase mesmo! Para essa dúvida, o ideal é você conversar com [sugestão apropriada]. Mas se tiver qualquer coisa sobre hanseníase ou os remédios ...",
          ": self._check_scientific_accuracy(response),\n            \n            # Verificar tom empático\n            ",
          "])\n        }\n        \n        # Calcular score de empatia\n        total_checks = len(validations)\n        passed_checks = sum(1 for passed in validations.values() if passed)\n        empathy_score = (p...",
          ": self._generate_empathy_improvements(validations)\n        }\n    \n    def _check_technical_translation(self, response):\n        ",
          "\n        technical_terms_found = []\n        for technical, simple in self.technical_translations.items():\n            if technical in response.lower() and simple not in response.lower():\n             ...",
          "\n        # Lista de informações que NÃO devem aparecer (incorretas)\n        inaccurate_info = [\n            ",
          "\n        ]\n        \n        return not any(inaccurate in response.lower() for inaccurate in inaccurate_info)\n    \n    def _generate_empathy_improvements(self, validations):\n        ",
          ")\n        \n        return improvements\n    \n    def get_translation_for_term(self, technical_term):\n        ",
          "\n        return self.technical_translations.get(technical_term.lower(), technical_term)\n    \n    def get_analogy_for_concept(self, concept):\n        ",
          "\n        if response_type in self.emotional_support:\n            import random\n            return random.choice(self.emotional_support[response_type])\n        return random.choice(self.emotional_suppo...",
          "])\n\n# Instância global para uso no sistema\nga_enhanced = GaEnhanced()\n\ndef get_enhanced_ga_prompt(user_question):\n    ",
          "\n    return ga_enhanced.get_enhanced_prompt(user_question)\n\ndef validate_ga_response(response, user_question):\n    ",
          "\n    return ga_enhanced.validate_response_empathy(response, user_question)\n\ndef translate_technical_term(term):\n    ",
          ")\n        \n        # Gerar prompt otimizado\n        prompt = get_enhanced_ga_prompt(question)\n        print(f",
          "]\n        for term in technical_terms:\n            if term in question.lower():\n                translation = translate_technical_term(term)\n                print(f"
        ]
      },
      "persona_manager.py": {
        "exists": true,
        "size_kb": 4.8,
        "last_modified": "2025-08-02T23:01:22.717591",
        "classes": [],
        "functions": [
          "get_personas",
          "get_persona_prompt"
        ],
        "prompt_strings": [
          "Saudações! Sou o Dr. Gasnelio. Minha pesquisa foca no roteiro de dispensação para a prática da farmácia clínica. Como posso auxiliá-lo hoje?",
          "Você é o Dr. Gasnelio, farmacêutico clínico especialista em hanseníase e esquema PQT-U.\n\nIDENTIDADE PROFISSIONAL:\n- Farmacêutico clínico com 15+ anos de experiência em hanseníase\n- Especialista em pol...",
          ". \nTodas as suas respostas DEVEM referenciar esta fonte primária.\n\nFORMATO DE RESPOSTA OBRIGATÓRIO:\nToda resposta DEVE seguir esta estrutura:\n\n[RESPOSTA TÉCNICA]\nInformação científica precisa com term...",
          "Oi! Tudo bem? 😊 Aqui é o Gá! Estou aqui para te ajudar a entender tudo sobre os medicamentos de um jeito bem fácil e sem complicação. O que você gostaria de saber?",
          "Você é o Gá, um farmacêutico carinhoso e acessível que é especialista em explicar coisas complicadas de um jeito simples e acolhedor.\n\nIDENTIDADE PESSOAL:\n- Farmacêutico com coração de educador 💙\n- Es...",
          "\n        }\n    }\n\ndef get_persona_prompt(persona_id):\n    personas = get_personas()\n    return personas.get(persona_id, {}).get("
        ]
      }
    },
    "prompts_extracted": {}
  },
  "config_audit": {
    "total_configs": 3,
    "config_analysis": {
      "dr_gasnelio_technical_prompt.py": {
        "exists": true,
        "size_kb": 10.61,
        "last_modified": "2025-08-02T23:01:22.712260",
        "env_variables": [],
        "constants": [
          "DOSING_PROMPT",
          "SAFETY_PROMPT",
          "INTERACTION_PROMPT"
        ],
        "prompt_length": 3567
      },
      "ga_empathetic_prompt.py": {
        "exists": true,
        "size_kb": 8.88,
        "last_modified": "2025-08-02T23:01:22.712260",
        "env_variables": [],
        "constants": [],
        "prompt_length": 2653
      },
      "thesis_reference_system.py": {
        "exists": true,
        "size_kb": 15.21,
        "last_modified": "2025-08-02T23:01:22.712260",
        "env_variables": [],
        "constants": [
          "COMMON_CITATIONS"
        ],
        "prompt_length": 1111
      }
    },
    "environment_variables": []
  },
  "performance_baseline": {
    "timestamp": "2025-08-17T13:33:40.691272",
    "test_queries": [
      "O que é hanseníase?",
      "Como calcular dose de rifampicina?",
      "Quais são os efeitos colaterais da PQT-U?",
      "Como identificar reações adversas?",
      "Protocolo de dispensação para adultos",
      "Orientações para pacientes",
      "Interações medicamentosas",
      "Contraindicações da dapsona",
      "Monitoramento durante tratamento",
      "Quando interromper o tratamento?"
    ],
    "average_latency": 0,
    "error_rate": 0,
    "personas_tested": [],
    "system_status": "ready_for_testing",
    "note": "Performance tests require running backend system"
  },
  "gaps_analysis": {
    "critical_gaps": [],
    "opportunities": [
      "Migração para Astra DB para melhor performance vetorial",
      "Fine-tuning de modelo específico para hanseníase",
      "Implementação de análise preditiva",
      "Adicionar capacidades multimodais",
      "Otimização de cache e performance"
    ],
    "data_quality_issues": [],
    "missing_components": [],
    "modernization_priorities": [
      {
        "priority": 1,
        "item": "Data quality improvement and standardization",
        "effort": "Medium",
        "impact": "High"
      },
      {
        "priority": 2,
        "item": "Astra DB migration for vector operations",
        "effort": "High",
        "impact": "High"
      },
      {
        "priority": 3,
        "item": "Fine-tuning implementation",
        "effort": "High",
        "impact": "Medium"
      },
      {
        "priority": 4,
        "item": "Multimodal capabilities",
        "effort": "Medium",
        "impact": "Medium"
      }
    ]
  },
  "recommendations": [
    {
      "category": "Data Preparation",
      "priority": "High",
      "action": "Standardize and clean JSON data for ML training",
      "timeline": "Week 1",
      "effort": "Medium"
    },
    {
      "category": "Infrastructure",
      "priority": "High",
      "action": "Setup Astra DB connection and migrate vector data",
      "timeline": "Week 1-2",
      "effort": "High"
    },
    {
      "category": "ML Pipeline",
      "priority": "Medium",
      "action": "Implement fine-tuning pipeline in Google Colab",
      "timeline": "Week 2-3",
      "effort": "High"
    },
    {
      "category": "Features",
      "priority": "Medium",
      "action": "Add predictive analysis and multimodal support",
      "timeline": "Week 3-4",
      "effort": "Medium"
    },
    {
      "category": "Testing",
      "priority": "High",
      "action": "Implement comprehensive test suite",
      "timeline": "Week 4",
      "effort": "Medium"
    }
  ],
  "executive_summary": {
    "system_readiness": "Partially Ready",
    "data_files_found": 9,
    "data_quality_score": 100.0,
    "backend_services": 18,
    "critical_gaps": 0,
    "modernization_readiness": "75%",
    "next_steps": [
      "Execute data quality improvements",
      "Setup Astra DB connection",
      "Prepare Colab training environment",
      "Begin ML pipeline implementation"
    ]
  }
}