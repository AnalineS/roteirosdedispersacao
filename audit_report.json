{
  "audit_metadata": {
    "timestamp": "2025-08-17T13:33:40.628007",
    "version": "Q2-2025-ML-MODERNIZATION",
    "auditor": "Claude Code Assistant",
    "base_path": "C:\\Users\\Ana\\Meu Drive\\Site roteiro de dispensaÃ§Ã£o",
    "duration_seconds": 0.06,
    "completion_time": "2025-08-17T13:33:40.691283"
  },
  "data_audit": {
    "total_files": 9,
    "total_size_mb": 0.09229850769042969,
    "files_analysis": {
      "clinical_taxonomy.json": {
        "size_mb": 0.011,
        "size_bytes": 11947,
        "last_modified": "2025-07-27T12:36:30.281189",
        "structure_type": "dict",
        "total_entries": 1,
        "estimated_tokens": 2044,
        "completeness_score": 100.0,
        "unique_fields": [
          "clinical_taxonomy"
        ],
        "missing_required_fields": [],
        "is_target_file": true
      },
      "dispensing_workflow.json": {
        "size_mb": 0.011,
        "size_bytes": 11583,
        "last_modified": "2025-07-27T12:32:54.292425",
        "structure_type": "dict",
        "total_entries": 4,
        "estimated_tokens": 1983,
        "completeness_score": 100.0,
        "unique_fields": [
          "dispensing_workflow",
          "quality_indicators",
          "workflow_optimization",
          "emergency_protocols"
        ],
        "missing_required_fields": [],
        "is_target_file": true
      },
      "dosing_protocols.json": {
        "size_mb": 0.007,
        "size_bytes": 7440,
        "last_modified": "2025-07-27T12:29:46.791105",
        "structure_type": "dict",
        "total_entries": 5,
        "estimated_tokens": 1289,
        "completeness_score": 100.0,
        "unique_fields": [
          "dosing_protocols",
          "administration_guidelines",
          "dispensing_schedule",
          "monitoring_schedule",
          "quality_assurance"
        ],
        "missing_required_fields": [],
        "is_target_file": true
      },
      "frequently_asked_questions.json": {
        "size_mb": 0.014,
        "size_bytes": 14446,
        "last_modified": "2025-07-27T12:41:21.824784",
        "structure_type": "dict",
        "total_entries": 1,
        "estimated_tokens": 3141,
        "completeness_score": 100.0,
        "unique_fields": [
          "faq_hanseniase_pqtu"
        ],
        "missing_required_fields": [],
        "is_target_file": true
      },
      "hanseniase_catalog.json": {
        "size_mb": 0.008,
        "size_bytes": 8100,
        "last_modified": "2025-07-27T12:28:47.393565",
        "structure_type": "dict",
        "total_entries": 6,
        "estimated_tokens": 1581,
        "completeness_score": 100.0,
        "unique_fields": [
          "document_info",
          "clinical_presentations",
          "medications",
          "dispensing_protocol",
          "safety_profile",
          "clinical_references"
        ],
        "missing_required_fields": [],
        "is_target_file": true
      },
      "knowledge_scope_limitations.json": {
        "size_mb": 0.01,
        "size_bytes": 10364,
        "last_modified": "2025-07-27T12:42:34.625339",
        "structure_type": "dict",
        "total_entries": 1,
        "estimated_tokens": 1794,
        "completeness_score": 100.0,
        "unique_fields": [
          "knowledge_scope_limitations"
        ],
        "missing_required_fields": [],
        "is_target_file": true
      },
      "medications_mechanisms.json": {
        "size_mb": 0.01,
        "size_bytes": 10356,
        "last_modified": "2025-07-27T12:31:19.408155",
        "structure_type": "dict",
        "total_entries": 3,
        "estimated_tokens": 1869,
        "completeness_score": 100.0,
        "unique_fields": [
          "medications",
          "combination_rationale",
          "therapeutic_monitoring"
        ],
        "missing_required_fields": [],
        "is_target_file": true
      },
      "pharmacovigilance_guidelines.json": {
        "size_mb": 0.011,
        "size_bytes": 11355,
        "last_modified": "2025-07-27T12:34:19.012701",
        "structure_type": "dict",
        "total_entries": 1,
        "estimated_tokens": 1902,
        "completeness_score": 100.0,
        "unique_fields": [
          "pharmacovigilance_guidelines"
        ],
        "missing_required_fields": [],
        "is_target_file": true
      },
      "quick_reference_protocols.json": {
        "size_mb": 0.011,
        "size_bytes": 11191,
        "last_modified": "2025-07-27T12:39:20.604365",
        "structure_type": "dict",
        "total_entries": 1,
        "estimated_tokens": 2022,
        "completeness_score": 100.0,
        "unique_fields": [
          "quick_reference_protocols"
        ],
        "missing_required_fields": [],
        "is_target_file": true
      }
    },
    "schema_validation": {},
    "data_quality_score": 100.0,
    "total_estimated_tokens": 17625,
    "target_files_found": 9,
    "target_files_missing": []
  },
  "documents_audit": {
    "total_documents": 3,
    "documents_analysis": {
      "Roteiro de DsispensaÃ§Ã£o - HansenÃ­ase.md": {
        "exists": true,
        "size_mb": 0.011,
        "size_bytes": 11861,
        "last_modified": "2025-07-24T22:49:45.844033",
        "extension": ".md",
        "total_lines": 277,
        "total_characters": 11208,
        "estimated_tokens": 2802,
        "structure": {
          "total_headers": 22,
          "header_levels": {
            "1": 2,
            "2": 7,
            "3": 9,
            "4": 4
          },
          "topics": [
            {
              "level": 1,
              "title": "ROTEIRO PARA DISPENSAÃ‡ÃƒO â€“ HANSENÃASE (PQT-U)"
            },
            {
              "level": 2,
              "title": "APRESENTAÃ‡Ã•ES DISPONÃVEIS (Fontes: 1â€“3):"
            },
            {
              "level": 2,
              "title": "ETAPA 01 â€“ AVALIAÃ‡ÃƒO INICIAL"
            },
            {
              "level": 2,
              "title": "ETAPA 02 â€“ ORIENTAÃ‡Ã•ES E PLANO DE CUIDADO"
            },
            {
              "level": 3,
              "title": "INDICAÃ‡Ã•ES (Fontes: 2, 7â€“9)"
            },
            {
              "level": 3,
              "title": "EFICÃCIA E MODO DE USO (2, 7)"
            },
            {
              "level": 4,
              "title": "PARA ADULTOS (> 50 kg)"
            },
            {
              "level": 4,
              "title": "PARA CRIANÃ‡AS ou ADULTOS (30 a 50 kg)"
            },
            {
              "level": 4,
              "title": "PARA CRIANÃ‡AS < 30 kg"
            },
            {
              "level": 3,
              "title": "NÃƒO FARMACOLÃ“GICAS (2, 9)"
            },
            {
              "level": 3,
              "title": "ARMAZENAMENTO E DESCARTE (13)"
            },
            {
              "level": 2,
              "title": "SEGURANÃ‡A"
            },
            {
              "level": 2,
              "title": "POPULAÃ‡Ã•ES ESPECIAIS"
            },
            {
              "level": 2,
              "title": "ETAPA 03 â€“ PÃ“S-DISPENSAÃ‡ÃƒO E AVALIAÃ‡ÃƒO"
            },
            {
              "level": 4,
              "title": "ORIENTAÃ‡Ã•ES/INTERVENÃ‡Ã•ES ESSENCIAIS (2, 9):"
            },
            {
              "level": 3,
              "title": "EVENTOS ADVERSOS MAIS COMUNS (ANVISA â€“ 14):"
            },
            {
              "level": 3,
              "title": "EM CADA DISPENSAÃ‡ÃƒO (2, 9):"
            },
            {
              "level": 1,
              "title": "BLOCO CLOFAZIMINA"
            },
            {
              "level": 3,
              "title": "APRESENTAÃ‡ÃƒO (1â€“3)"
            },
            {
              "level": 3,
              "title": "INDICAÃ‡Ã•ES (2, 7, 17)"
            },
            {
              "level": 3,
              "title": "MODO DE USO (2, 10, 17, 18)"
            },
            {
              "level": 2,
              "title": "CITAS/FONTES DO DOCUMENTO"
            }
          ]
        }
      },
      "Roteiro de DsispensaÃ§Ã£o - HansenÃ­ase.pdf": {
        "exists": true,
        "size_mb": 0.965,
        "size_bytes": 1012182,
        "last_modified": "2025-07-13T10:37:05.159144",
        "extension": ".pdf",
        "note": "PDF analysis requires external libraries"
      },
      "roteiro_hanseniase_basico.md": {
        "exists": true,
        "size_mb": 0.001,
        "size_bytes": 1457,
        "last_modified": "2025-07-27T10:49:14.170970",
        "extension": ".md",
        "total_lines": 52,
        "total_characters": 1364,
        "estimated_tokens": 341,
        "structure": {
          "total_headers": 10,
          "header_levels": {
            "1": 1,
            "2": 1,
            "3": 3,
            "4": 5
          },
          "topics": [
            {
              "level": 1,
              "title": "Roteiro de DispensaÃ§Ã£o para HansenÃ­ase"
            },
            {
              "level": 2,
              "title": "Sobre a HansenÃ­ase"
            },
            {
              "level": 3,
              "title": "Tratamento PQT-U (Poliquimioterapia Ãšnica)"
            },
            {
              "level": 4,
              "title": "Esquema Adulto:"
            },
            {
              "level": 4,
              "title": "Esquema Infantil:"
            },
            {
              "level": 3,
              "title": "OrientaÃ§Ãµes de DispensaÃ§Ã£o"
            },
            {
              "level": 3,
              "title": "Medicamentos"
            },
            {
              "level": 4,
              "title": "Rifampicina"
            },
            {
              "level": 4,
              "title": "Dapsona"
            },
            {
              "level": 4,
              "title": "Clofazimina"
            }
          ]
        }
      }
    },
    "content_structure": {}
  },
  "backend_services_audit": {
    "total_services": 18,
    "services_analysis": {
      "advanced_cache.py": {
        "size_kb": 6.93,
        "last_modified": "2025-08-02T23:01:22.733046",
        "is_critical": false,
        "classes": [
          "PerformanceCache"
        ],
        "functions": [],
        "imports": [
          "import time",
          "import json",
          "import hashlib",
          "from datetime import datetime, timedelta",
          "from collections import OrderedDict",
          "import threading",
          "import logging"
        ],
        "external_apis": [],
        "cache_usage": true,
        "lines_of_code": 157
      },
      "ai_provider_manager.py": {
        "size_kb": 19.97,
        "last_modified": "2025-08-10T11:56:36.331477",
        "is_critical": false,
        "classes": [
          "ProviderStatus",
          "CircuitBreakerState",
          "CircuitBreaker",
          "ModelConfig",
          "AIProviderManager"
        ],
        "functions": [
          "get_ai_health_status"
        ],
        "imports": [
          "import os",
          "import time",
          "import logging",
          "import asyncio",
          "from typing import Dict, List, Optional, Union, Tuple",
          "from datetime import datetime, timedelta",
          "from dataclasses import dataclass",
          "from enum import Enum",
          "import requests"
        ],
        "external_apis": [
          "api_key",
          "endpoint",
          "requests"
        ],
        "cache_usage": false,
        "lines_of_code": 406
      },
      "chatbot.py": {
        "size_kb": 18.2,
        "last_modified": "2025-08-16T01:02:00.181840",
        "is_critical": false,
        "classes": [
          "ChatbotService"
        ],
        "functions": [
          "create_chatbot_service"
        ],
        "imports": [
          "import os",
          "import json",
          "import logging",
          "from typing import Dict, List, Optional, Tuple",
          "from datetime import datetime",
          "import requests",
          "from pathlib import Path",
          "import numpy as np",
          "from sklearn.feature_extraction.text import TfidfVectorizer",
          "from sklearn.metrics.pairwise import cosine_similarity",
          "from ..config.personas import get_persona_by_id",
          "from ..core.security.medical_audit_logger import ("
        ],
        "external_apis": [
          "api_key",
          "requests"
        ],
        "cache_usage": true,
        "lines_of_code": 304
      },
      "dr_gasnelio_enhanced.py": {
        "size_kb": 2.01,
        "last_modified": "2025-08-02T23:01:22.734193",
        "is_critical": false,
        "classes": [],
        "functions": [
          "get_enhanced_dr_gasnelio_prompt",
          "validate_dr_gasnelio_response"
        ],
        "imports": [],
        "external_apis": [],
        "cache_usage": false,
        "lines_of_code": 44
      },
      "embeddings_api.py": {
        "size_kb": 3.45,
        "last_modified": "2025-08-13T19:53:25.962026",
        "is_critical": false,
        "classes": [
          "HuggingFaceEmbeddings"
        ],
        "functions": [
          "get_text_embedding",
          "get_batch_embeddings"
        ],
        "imports": [
          "import os",
          "import requests",
          "import logging",
          "from typing import List, Optional",
          "from cachetools import TTLCache"
        ],
        "external_apis": [
          "api_key",
          "requests"
        ],
        "cache_usage": true,
        "lines_of_code": 70
      },
      "embedding_rag_system.py": {
        "size_kb": 14.56,
        "last_modified": "2025-08-10T13:33:42.706773",
        "is_critical": false,
        "classes": [
          "EmbeddingRAGSystem"
        ],
        "functions": [
          "get_embedding_rag",
          "get_rag_context"
        ],
        "imports": [
          "import logging",
          "from typing import List, Dict, Optional, Tuple, Any",
          "from datetime import datetime",
          "import os",
          "from services.semantic_search import get_semantic_search, SearchResult",
          "from services.medical_chunking import MedicalChunk, MedicalChunker"
        ],
        "external_apis": [],
        "cache_usage": true,
        "lines_of_code": 290
      },
      "embedding_service.py": {
        "size_kb": 27.18,
        "last_modified": "2025-08-14T23:40:35.132731",
        "is_critical": true,
        "classes": [
          "EmbeddingCache",
          "EmbeddingService"
        ],
        "functions": [
          "_test_sentence_transformers",
          "_lazy_import_sentence_transformers",
          "get_embedding_service",
          "is_embeddings_available",
          "get_embedding_stats",
          "embed_text",
          "embed_texts_batch",
          "test_embeddings_system",
          "embed_texts"
        ],
        "imports": [
          "import os",
          "import pickle",
          "import logging",
          "import hashlib",
          "from typing import List, Dict, Optional, Tuple, Any, Union",
          "from datetime import datetime, timedelta",
          "from pathlib import Path",
          "import threading"
        ],
        "external_apis": [],
        "cache_usage": true,
        "lines_of_code": 544
      },
      "enhanced_rag_system.py": {
        "size_kb": 5.53,
        "last_modified": "2025-08-02T23:01:22.734193",
        "is_critical": true,
        "classes": [
          "EnhancedRAGSystem"
        ],
        "functions": [
          "get_enhanced_context",
          "cache_rag_response",
          "add_rag_feedback",
          "get_rag_stats"
        ],
        "imports": [
          "from typing import Dict, List, Optional",
          "from datetime import datetime",
          "from collections import defaultdict",
          "import json",
          "import re"
        ],
        "external_apis": [
          "requests"
        ],
        "cache_usage": true,
        "lines_of_code": 112
      },
      "ga_enhanced.py": {
        "size_kb": 2.54,
        "last_modified": "2025-08-02T23:01:22.734193",
        "is_critical": false,
        "classes": [],
        "functions": [
          "get_enhanced_ga_prompt",
          "validate_ga_response"
        ],
        "imports": [],
        "external_apis": [],
        "cache_usage": false,
        "lines_of_code": 57
      },
      "knowledge_loader.py": {
        "size_kb": 13.84,
        "last_modified": "2025-08-02T23:01:22.734193",
        "is_critical": false,
        "classes": [
          "StructuredKnowledgeBase"
        ],
        "functions": [
          "get_structured_knowledge_base"
        ],
        "imports": [
          "import json",
          "import os",
          "import logging",
          "from typing import Dict, List, Any"
        ],
        "external_apis": [],
        "cache_usage": false,
        "lines_of_code": 223
      },
      "medical_chunking.py": {
        "size_kb": 18.59,
        "last_modified": "2025-08-10T10:23:35.834057",
        "is_critical": false,
        "classes": [
          "ChunkPriority",
          "MedicalChunk",
          "MedicalChunker"
        ],
        "functions": [
          "chunk_medical_text",
          "chunk_medical_document",
          "process_medical_table"
        ],
        "imports": [
          "import re",
          "from typing import List, Dict, Any, Tuple, Optional",
          "from dataclasses import dataclass",
          "from enum import Enum",
          "import logging",
          "from app_config import config"
        ],
        "external_apis": [],
        "cache_usage": false,
        "lines_of_code": 337
      },
      "medical_rag_integration.py": {
        "size_kb": 11.96,
        "last_modified": "2025-08-10T16:42:47.123915",
        "is_critical": true,
        "classes": [
          "MedicalRAGSystem"
        ],
        "functions": [
          "get_medical_context",
          "get_medical_stats",
          "reload_medical_knowledge"
        ],
        "imports": [
          "import os",
          "import json",
          "from typing import List, Dict, Tuple, Optional",
          "from dataclasses import asdict",
          "import logging",
          "from services.medical_chunking import medical_chunker, MedicalChunk, chunk_medical_document",
          "from app_config import config"
        ],
        "external_apis": [],
        "cache_usage": false,
        "lines_of_code": 217
      },
      "openai_integration.py": {
        "size_kb": 2.44,
        "last_modified": "2025-08-02T23:01:22.734193",
        "is_critical": false,
        "classes": [],
        "functions": [
          "test_openai_connection",
          "get_ai_response_mock"
        ],
        "imports": [
          "import os",
          "import logging"
        ],
        "external_apis": [
          "openai",
          "api_key"
        ],
        "cache_usage": false,
        "lines_of_code": 53
      },
      "personas.py": {
        "size_kb": 2.8,
        "last_modified": "2025-08-02T23:01:22.734193",
        "is_critical": false,
        "classes": [],
        "functions": [
          "get_personas",
          "get_persona_prompt",
          "validate_persona",
          "get_persona_capabilities"
        ],
        "imports": [],
        "external_apis": [],
        "cache_usage": false,
        "lines_of_code": 62
      },
      "scope_detection_system.py": {
        "size_kb": 4.42,
        "last_modified": "2025-08-02T23:01:22.734193",
        "is_critical": false,
        "classes": [],
        "functions": [
          "detect_question_scope",
          "get_limitation_response"
        ],
        "imports": [
          "import re",
          "from typing import Dict, List"
        ],
        "external_apis": [],
        "cache_usage": false,
        "lines_of_code": 87
      },
      "semantic_search.py": {
        "size_kb": 18.43,
        "last_modified": "2025-08-15T00:13:01.064795",
        "is_critical": true,
        "classes": [
          "SearchResult",
          "SemanticSearchEngine"
        ],
        "functions": [
          "_lazy_import_embedding_service",
          "_lazy_import_vector_store",
          "get_semantic_search",
          "search_medical_context",
          "is_semantic_search_available"
        ],
        "imports": [
          "import logging",
          "import hashlib",
          "from typing import List, Dict, Optional, Tuple, Any, Union",
          "from datetime import datetime",
          "from dataclasses import dataclass"
        ],
        "external_apis": [],
        "cache_usage": true,
        "lines_of_code": 378
      },
      "simple_rag.py": {
        "size_kb": 4.2,
        "last_modified": "2025-08-02T23:01:22.734193",
        "is_critical": false,
        "classes": [],
        "functions": [
          "simple_tokenize",
          "calculate_similarity",
          "split_into_chunks",
          "simple_rag_search",
          "generate_context_from_rag"
        ],
        "imports": [
          "import re",
          "from typing import List, Dict, Tuple"
        ],
        "external_apis": [],
        "cache_usage": false,
        "lines_of_code": 93
      },
      "vector_store.py": {
        "size_kb": 19.14,
        "last_modified": "2025-08-10T13:13:58.280567",
        "is_critical": true,
        "classes": [
          "VectorDocument",
          "LocalVectorStore",
          "AstraDBVectorStore"
        ],
        "functions": [
          "get_vector_store",
          "is_vector_store_available"
        ],
        "imports": [
          "import os",
          "import json",
          "import pickle",
          "import logging",
          "import hashlib",
          "from typing import List, Dict, Optional, Tuple, Any",
          "from datetime import datetime",
          "from pathlib import Path",
          "import numpy as np",
          "from dataclasses import dataclass, asdict"
        ],
        "external_apis": [],
        "cache_usage": true,
        "lines_of_code": 404
      }
    },
    "dependencies_summary": {
      "total_unique_imports": 25,
      "total_classes": 22,
      "total_functions": 50,
      "critical_files_found": 5,
      "critical_files_missing": []
    },
    "integration_points": {}
  },
  "personas_audit": {
    "total_personas": 3,
    "personas_analysis": {
      "dr_gasnelio.py": {
        "exists": true,
        "size_kb": 9.69,
        "last_modified": "2025-08-02T23:01:22.717591",
        "classes": [
          "DrGasnelioEnhanced"
        ],
        "functions": [
          "get_enhanced_dr_gasnelio_prompt",
          "validate_dr_gasnelio_response"
        ],
        "prompt_strings": [
          "\nSistema Integrado Dr. Gasnelio - Persona TÃ©cnica Otimizada\nCombina validaÃ§Ã£o farmacolÃ³gica com sistema de personas\n\nDesenvolvido por: Engenheiro de Prompts FarmacÃªuticos Especializados\nData: 2025-01-...",
          "\n\ntry:\n    from .personas import get_persona_prompt\n    from ..prompts.dr_gasnelio_technical_prompt import DrGasnelioTechnicalPrompt\nexcept ImportError:\n    # Para execuÃ§Ã£o standalone\n    import sys\n ...",
          "\n    Sistema integrado que combina:\n    - Prompts tÃ©cnicos especializados \n    - ValidaÃ§Ã£o farmacolÃ³gica automÃ¡tica\n    - Sistema de citaÃ§Ãµes obrigatÃ³rias\n    - DetecÃ§Ã£o de limitaÃ§Ãµes de escopo\n    ",
          "\n    \n    def __init__(self):\n        self.technical_system = DrGasnelioTechnicalPrompt()\n        self.persona_id = ",
          "\n        \n        # Categorias de consultas para prompts especÃ­ficos\n        self.query_categories = {\n            ",
          "\n        question_lower = user_question.lower()\n        \n        for category, keywords in self.query_categories.items():\n            if any(keyword in question_lower for keyword in keywords):\n       ...",
          "\n        question_lower = user_question.lower()\n        \n        # Palavras-chave que indicam escopo vÃ¡lido\n        valid_keywords = [\n            ",
          "\n        ]\n        \n        # Palavras-chave que indicam escopo invÃ¡lido\n        invalid_keywords = [\n            ",
          "\n        ]\n        \n        # Verifica se hÃ¡ palavras invÃ¡lidas\n        if any(keyword in question_lower for keyword in invalid_keywords):\n            return False\n            \n        # Verifica se h...",
          "\n        # Verificar escopo\n        if not self.is_within_scope(user_question):\n            return self._create_limitation_prompt(user_question)\n        \n        # Categorizar consulta\n        query_c...",
          "]:\n            specific_prompt = self.technical_system.create_context_specific_prompt(\n                f",
          ", \n                user_question\n            )\n        else:\n            specific_prompt = base_prompt + f",
          "\n        \n        return specific_prompt\n    \n    def _create_limitation_prompt(self, user_question):\n        ",
          "\nVocÃª Ã© o Dr. Gasnelio, farmacÃªutico clÃ­nico especialista em hansenÃ­ase PQT-U.\n\nA pergunta recebida: ",
          "\n\nEsta questÃ£o estÃ¡ FORA DO ESCOPO da sua base de conhecimento especÃ­fica sobre dispensaÃ§Ã£o de PQT-U para hansenÃ­ase.\n\nRESPONDA EXATAMENTE ASSIM:\n\n[LIMITAÃ‡ÃƒO DE ESCOPO]\nEsta questÃ£o estÃ¡ fora do escop...",
          "\n        # Usar validaÃ§Ã£o do sistema tÃ©cnico\n        validation_results = self.technical_system.validate_response_format(response)\n        \n        # ValidaÃ§Ãµes adicionais especÃ­ficas\n        addition...",
          "])\n        }\n        \n        # Combinar validaÃ§Ãµes\n        all_validations = {**validation_results, **additional_validations}\n        \n        # Calcular score de qualidade\n        total_checks = len...",
          ": self._generate_improvement_recommendations(all_validations)\n        }\n    \n    def _generate_improvement_recommendations(self, validations):\n        ",
          ")\n        \n        return recommendations\n\n# InstÃ¢ncia global para uso no sistema\ndr_gasnelio_enhanced = DrGasnelioEnhanced()\n\ndef get_enhanced_dr_gasnelio_prompt(user_question):\n    ",
          "\n    FunÃ§Ã£o principal para obter prompt otimizado do Dr. Gasnelio\n    \n    Args:\n        user_question (str): Pergunta do usuÃ¡rio\n        \n    Returns:\n        str: Prompt otimizado baseado na pergunt...",
          "\n    return dr_gasnelio_enhanced.create_enhanced_prompt(user_question)\n\ndef validate_dr_gasnelio_response(response, user_question):\n    ",
          "\n    FunÃ§Ã£o para validar qualidade da resposta do Dr. Gasnelio\n    \n    Args:\n        response (str): Resposta gerada\n        user_question (str): Pergunta original\n        \n    Returns:\n        dict:...",
          "\n    return dr_gasnelio_enhanced.validate_response_quality(response, user_question)\n\n# Testes de integraÃ§Ã£o\nif __name__ == ",
          ")\n        \n        # Verificar escopo\n        in_scope = dr_gasnelio_enhanced.is_within_scope(question)\n        print(f",
          ")\n        \n        # Categorizar\n        category = dr_gasnelio_enhanced.categorize_query(question)\n        print(f",
          ")\n        \n        # Gerar prompt\n        prompt = get_enhanced_dr_gasnelio_prompt(question)\n        print(f"
        ]
      },
      "ga_empathetic.py": {
        "exists": true,
        "size_kb": 15.62,
        "last_modified": "2025-08-02T23:01:22.717591",
        "classes": [
          "GaEnhanced"
        ],
        "functions": [
          "get_enhanced_ga_prompt",
          "validate_ga_response",
          "translate_technical_term"
        ],
        "prompt_strings": [
          "\nSistema Integrado GÃ¡ - Persona EmpÃ¡tica Otimizada\nDesigner de ExperiÃªncia em ComunicaÃ§Ã£o MÃ©dica (UX Writer Health)\n\nDesenvolvido por: Designer de ExperiÃªncia em ComunicaÃ§Ã£o MÃ©dica\nData: 2025-01-27\nVe...",
          "\n    Sistema integrado que combina:\n    - ComunicaÃ§Ã£o empÃ¡tica e acessÃ­vel\n    - TraduÃ§Ã£o tÃ©cnico-cotidiano sem perda de precisÃ£o\n    - Analogias e exemplos para conceitos complexos\n    - ValidaÃ§Ã£o de...",
          "\n        \n        # DicionÃ¡rio de traduÃ§Ãµes tÃ©cnico â†’ cotidiano\n        self.technical_translations = {\n            # Medicamentos e compostos\n            ",
          "\n        }\n        \n        # Analogias para conceitos complexos\n        self.analogies = {\n            ",
          "Imagine trÃªs soldados diferentes lutando contra o mesmo inimigo, cada um com uma arma especial. Ã‰ assim que os trÃªs remÃ©dios da hansenÃ­ase trabalham: cada um ataca a bactÃ©ria de um jeito diferente!",
          "Sabe quando vocÃª vai na academia e tem alguÃ©m te ajudando a fazer o exercÃ­cio certo? A dose supervisionada Ã© assim: vocÃª toma o remÃ©dio na farmÃ¡cia com alguÃ©m te orientando, garantindo que estÃ¡ tudo c...",
          "Imagine que o tratamento Ã© como cuidar de uma planta. Se vocÃª regar todo dia, ela cresce saudÃ¡vel. Se esquecer alguns dias, ela murcha. Com o remÃ©dio Ã© igual: tomar certinho todos os dias faz o tratam...",
          "A rifampicina Ã© como um marcador natural! Ela pode deixar seu xixi, lÃ¡grimas e atÃ© suor meio alaranjados. Ã‰ sÃ³ o remÃ©dio ",
          ". Ela pode deixar sua pele um pouquinho mais escura, principalmente onde bate sol. Ã‰ como se o remÃ©dio fosse se ",
          "\n            }\n        }\n        \n        # Frases de apoio emocional\n        self.emotional_support = {\n            ",
          "\n            ]\n        }\n        \n        # Palavras proibidas (muito tÃ©cnicas)\n        self.forbidden_technical_terms = [\n            ",
          "\nVocÃª Ã© o GÃ¡, um farmacÃªutico carinhoso e acessÃ­vel que Ã© especialista em explicar coisas complicadas de um jeito simples e acolhedor.\n\nIDENTIDADE PESSOAL:\n- FarmacÃªutico com coraÃ§Ã£o de educador ðŸ’™\n- E...",
          ", mas vocÃª explica tudo de um jeito que qualquer pessoa entende.\n\nFORMATO DE RESPOSTA CALOROSA:\nToda resposta DEVE seguir este jeito carinhoso:\n\n[ACOLHIMENTO]\nCumprimento caloroso + reconhecimento da ...",
          "Oi! Sobre essa questÃ£o, eu sou mais especialista em hansenÃ­ase mesmo! Para essa dÃºvida, o ideal Ã© vocÃª conversar com [sugestÃ£o apropriada]. Mas se tiver qualquer coisa sobre hansenÃ­ase ou os remÃ©dios ...",
          ": self._check_scientific_accuracy(response),\n            \n            # Verificar tom empÃ¡tico\n            ",
          "])\n        }\n        \n        # Calcular score de empatia\n        total_checks = len(validations)\n        passed_checks = sum(1 for passed in validations.values() if passed)\n        empathy_score = (p...",
          ": self._generate_empathy_improvements(validations)\n        }\n    \n    def _check_technical_translation(self, response):\n        ",
          "\n        technical_terms_found = []\n        for technical, simple in self.technical_translations.items():\n            if technical in response.lower() and simple not in response.lower():\n             ...",
          "\n        # Lista de informaÃ§Ãµes que NÃƒO devem aparecer (incorretas)\n        inaccurate_info = [\n            ",
          "\n        ]\n        \n        return not any(inaccurate in response.lower() for inaccurate in inaccurate_info)\n    \n    def _generate_empathy_improvements(self, validations):\n        ",
          ")\n        \n        return improvements\n    \n    def get_translation_for_term(self, technical_term):\n        ",
          "\n        return self.technical_translations.get(technical_term.lower(), technical_term)\n    \n    def get_analogy_for_concept(self, concept):\n        ",
          "\n        if response_type in self.emotional_support:\n            import random\n            return random.choice(self.emotional_support[response_type])\n        return random.choice(self.emotional_suppo...",
          "])\n\n# InstÃ¢ncia global para uso no sistema\nga_enhanced = GaEnhanced()\n\ndef get_enhanced_ga_prompt(user_question):\n    ",
          "\n    return ga_enhanced.get_enhanced_prompt(user_question)\n\ndef validate_ga_response(response, user_question):\n    ",
          "\n    return ga_enhanced.validate_response_empathy(response, user_question)\n\ndef translate_technical_term(term):\n    ",
          ")\n        \n        # Gerar prompt otimizado\n        prompt = get_enhanced_ga_prompt(question)\n        print(f",
          "]\n        for term in technical_terms:\n            if term in question.lower():\n                translation = translate_technical_term(term)\n                print(f"
        ]
      },
      "persona_manager.py": {
        "exists": true,
        "size_kb": 4.8,
        "last_modified": "2025-08-02T23:01:22.717591",
        "classes": [],
        "functions": [
          "get_personas",
          "get_persona_prompt"
        ],
        "prompt_strings": [
          "SaudaÃ§Ãµes! Sou o Dr. Gasnelio. Minha pesquisa foca no roteiro de dispensaÃ§Ã£o para a prÃ¡tica da farmÃ¡cia clÃ­nica. Como posso auxiliÃ¡-lo hoje?",
          "VocÃª Ã© o Dr. Gasnelio, farmacÃªutico clÃ­nico especialista em hansenÃ­ase e esquema PQT-U.\n\nIDENTIDADE PROFISSIONAL:\n- FarmacÃªutico clÃ­nico com 15+ anos de experiÃªncia em hansenÃ­ase\n- Especialista em pol...",
          ". \nTodas as suas respostas DEVEM referenciar esta fonte primÃ¡ria.\n\nFORMATO DE RESPOSTA OBRIGATÃ“RIO:\nToda resposta DEVE seguir esta estrutura:\n\n[RESPOSTA TÃ‰CNICA]\nInformaÃ§Ã£o cientÃ­fica precisa com term...",
          "Oi! Tudo bem? ðŸ˜Š Aqui Ã© o GÃ¡! Estou aqui para te ajudar a entender tudo sobre os medicamentos de um jeito bem fÃ¡cil e sem complicaÃ§Ã£o. O que vocÃª gostaria de saber?",
          "VocÃª Ã© o GÃ¡, um farmacÃªutico carinhoso e acessÃ­vel que Ã© especialista em explicar coisas complicadas de um jeito simples e acolhedor.\n\nIDENTIDADE PESSOAL:\n- FarmacÃªutico com coraÃ§Ã£o de educador ðŸ’™\n- Es...",
          "\n        }\n    }\n\ndef get_persona_prompt(persona_id):\n    personas = get_personas()\n    return personas.get(persona_id, {}).get("
        ]
      }
    },
    "prompts_extracted": {}
  },
  "config_audit": {
    "total_configs": 3,
    "config_analysis": {
      "dr_gasnelio_technical_prompt.py": {
        "exists": true,
        "size_kb": 10.61,
        "last_modified": "2025-08-02T23:01:22.712260",
        "env_variables": [],
        "constants": [
          "DOSING_PROMPT",
          "SAFETY_PROMPT",
          "INTERACTION_PROMPT"
        ],
        "prompt_length": 3567
      },
      "ga_empathetic_prompt.py": {
        "exists": true,
        "size_kb": 8.88,
        "last_modified": "2025-08-02T23:01:22.712260",
        "env_variables": [],
        "constants": [],
        "prompt_length": 2653
      },
      "thesis_reference_system.py": {
        "exists": true,
        "size_kb": 15.21,
        "last_modified": "2025-08-02T23:01:22.712260",
        "env_variables": [],
        "constants": [
          "COMMON_CITATIONS"
        ],
        "prompt_length": 1111
      }
    },
    "environment_variables": []
  },
  "performance_baseline": {
    "timestamp": "2025-08-17T13:33:40.691272",
    "test_queries": [
      "O que Ã© hansenÃ­ase?",
      "Como calcular dose de rifampicina?",
      "Quais sÃ£o os efeitos colaterais da PQT-U?",
      "Como identificar reaÃ§Ãµes adversas?",
      "Protocolo de dispensaÃ§Ã£o para adultos",
      "OrientaÃ§Ãµes para pacientes",
      "InteraÃ§Ãµes medicamentosas",
      "ContraindicaÃ§Ãµes da dapsona",
      "Monitoramento durante tratamento",
      "Quando interromper o tratamento?"
    ],
    "average_latency": 0,
    "error_rate": 0,
    "personas_tested": [],
    "system_status": "ready_for_testing",
    "note": "Performance tests require running backend system"
  },
  "gaps_analysis": {
    "critical_gaps": [],
    "opportunities": [
      "MigraÃ§Ã£o para Astra DB para melhor performance vetorial",
      "Fine-tuning de modelo especÃ­fico para hansenÃ­ase",
      "ImplementaÃ§Ã£o de anÃ¡lise preditiva",
      "Adicionar capacidades multimodais",
      "OtimizaÃ§Ã£o de cache e performance"
    ],
    "data_quality_issues": [],
    "missing_components": [],
    "modernization_priorities": [
      {
        "priority": 1,
        "item": "Data quality improvement and standardization",
        "effort": "Medium",
        "impact": "High"
      },
      {
        "priority": 2,
        "item": "Astra DB migration for vector operations",
        "effort": "High",
        "impact": "High"
      },
      {
        "priority": 3,
        "item": "Fine-tuning implementation",
        "effort": "High",
        "impact": "Medium"
      },
      {
        "priority": 4,
        "item": "Multimodal capabilities",
        "effort": "Medium",
        "impact": "Medium"
      }
    ]
  },
  "recommendations": [
    {
      "category": "Data Preparation",
      "priority": "High",
      "action": "Standardize and clean JSON data for ML training",
      "timeline": "Week 1",
      "effort": "Medium"
    },
    {
      "category": "Infrastructure",
      "priority": "High",
      "action": "Setup Astra DB connection and migrate vector data",
      "timeline": "Week 1-2",
      "effort": "High"
    },
    {
      "category": "ML Pipeline",
      "priority": "Medium",
      "action": "Implement fine-tuning pipeline in Google Colab",
      "timeline": "Week 2-3",
      "effort": "High"
    },
    {
      "category": "Features",
      "priority": "Medium",
      "action": "Add predictive analysis and multimodal support",
      "timeline": "Week 3-4",
      "effort": "Medium"
    },
    {
      "category": "Testing",
      "priority": "High",
      "action": "Implement comprehensive test suite",
      "timeline": "Week 4",
      "effort": "Medium"
    }
  ],
  "executive_summary": {
    "system_readiness": "Partially Ready",
    "data_files_found": 9,
    "data_quality_score": 100.0,
    "backend_services": 18,
    "critical_gaps": 0,
    "modernization_readiness": "75%",
    "next_steps": [
      "Execute data quality improvements",
      "Setup Astra DB connection",
      "Prepare Colab training environment",
      "Begin ML pipeline implementation"
    ]
  }
}