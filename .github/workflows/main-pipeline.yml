name: "[PROD] Pipeline de Producao Completo"

on:
  push:
    branches: [main]
    paths:
      - 'apps/backend/**'
      - 'apps/frontend-nextjs/**'
      - 'package.json'
      - 'package-lock.json'
      - '.github/workflows/**'
  schedule:
    # Roda TODA SEGUNDA √†s 03:00 para economia do Snyk (200 testes/m√™s)
    - cron: '0 3 * * 1'
  workflow_dispatch:
    inputs:
      skip_tests:
        description: 'Pular testes (apenas emergencias)'
        required: false
        default: false
        type: boolean
      force_deploy:
        description: 'Forcar deploy mesmo com falhas'
        required: false
        default: false
        type: boolean

permissions:
  contents: write
  pull-requests: read
  security-events: write
  actions: read
  id-token: write

env:
  NODE_VERSION: '18'
  PYTHON_VERSION: '3.11'
  TELEGRAM_TOKEN: ${{ secrets.TELEGRAM_TOKEN }}
  TELEGRAM_CHAT_ID: ${{ secrets.TELEGRAM_CHAT_ID }}
  SNYK_TOKEN: ${{ secrets.SNYK_TOKEN }}
  # Timeout global para evitar jobs infinitos
  GLOBAL_TIMEOUT: 30

jobs:
  detect-changes:
    name: "[DETECT] Detectar Mudancas"
    runs-on: ubuntu-latest
    outputs:
      backend-changed: ${{ steps.filter.outputs.backend }}
      frontend-changed: ${{ steps.filter.outputs.frontend }}
      dependencies-changed: ${{ steps.filter.outputs.dependencies }}
      workflow-changed: ${{ steps.filter.outputs.workflows }}
      
    steps:
      - name: "[CHECKOUT] Checkout"
        uses: actions/checkout@b4ffde65f46336ab88eb53be808477a3936bae11  # v4.1.1
        with:
          fetch-depth: 2
          
      # PATHS-FILTER: Detec√ß√£o precisa de mudan√ßas (Economia ~60%)
      - name: "[FILTER] Detectar paths alterados"
        uses: dorny/paths-filter@de90cc6fb38fc0963ad72b210f1f284cd68cea36  # v3.0.2
        id: filter
        with:
          filters: |
            backend:
              - 'apps/backend/**'
            frontend:
              - 'apps/frontend-nextjs/**'
            dependencies:
              - 'package*.json'
              - '**/requirements*.txt'
            workflows:
              - '.github/workflows/**'
          
      # FALLBACK: Mant√©m l√≥gica original como backup
      - name: "[DETECT] Analisar Mudancas (Fallback)"
        id: changes
        if: steps.filter.outcome == 'failure'
        run: |
          echo "[WARNING] paths-filter falhou, usando detec√ß√£o tradicional..."
          
          BACKEND_CHANGED=false
          FRONTEND_CHANGED=false
          DEPS_CHANGED=false
          WORKFLOW_CHANGED=false
          
          if git diff --name-only HEAD~1 HEAD | grep -q "^apps/backend/"; then
            BACKEND_CHANGED=true
            echo "Backend alterado detectado"
          fi
          
          if git diff --name-only HEAD~1 HEAD | grep -q "^apps/frontend-nextjs/"; then
            FRONTEND_CHANGED=true
            echo "Frontend alterado detectado"
          fi
          
          if git diff --name-only HEAD~1 HEAD | grep -q -E "package\.json|package-lock\.json"; then
            DEPS_CHANGED=true
            echo "Dependencias alteradas detectadas"
          fi
          
          if git diff --name-only HEAD~1 HEAD | grep -q "^\.github/workflows/"; then
            WORKFLOW_CHANGED=true
            echo "Workflows alterados detectados"
          fi
          
          echo "backend=$BACKEND_CHANGED" >> $GITHUB_OUTPUT
          echo "frontend=$FRONTEND_CHANGED" >> $GITHUB_OUTPUT
          echo "dependencies=$DEPS_CHANGED" >> $GITHUB_OUTPUT
          echo "workflow=$WORKFLOW_CHANGED" >> $GITHUB_OUTPUT
          
      - name: "[SUMMARY] Resumo das mudan√ßas"
        run: |
          echo "üìä RESUMO DE MUDAN√áAS DETECTADAS:"
          echo "Backend: ${{ steps.filter.outputs.backend || steps.changes.outputs.backend }}"
          echo "Frontend: ${{ steps.filter.outputs.frontend || steps.changes.outputs.frontend }}"
          echo "Dependencies: ${{ steps.filter.outputs.dependencies || steps.changes.outputs.dependencies }}"
          echo "Workflows: ${{ steps.filter.outputs.workflows || steps.changes.outputs.workflow }}"

  security-quality-gates:
    name: "[SECURITY] Gates de Qualidade e Seguranca"
    runs-on: ubuntu-latest
    needs: detect-changes
    # CONDI√á√ÉO OTIMIZADA: Inclui schedule para Snyk semanal
    if: always() && (needs.detect-changes.outputs.backend-changed == 'true' || needs.detect-changes.outputs.frontend-changed == 'true' || needs.detect-changes.outputs.workflow-changed == 'true' || github.event_name == 'schedule')
    
    steps:
      - name: "[CHECKOUT] Checkout"
        uses: actions/checkout@v4
        
      # SECRET SCANNING GRATUITO: TruffleHog (sem limites)
      - name: "[SECURITY] TruffleHog Secret Scanning (FREE)"
        uses: trufflesecurity/trufflehog@2178b5ca0e5509ad8e2c9c0d6ec1e7e4158ced26  # v3.68.5
        with:
          path: ./
          base: ${{ github.event.repository.default_branch }}
          head: HEAD
          extra_args: --only-verified --fail
        continue-on-error: true  # N√£o falha build por secrets antigos
        
      - name: "[SECURITY] GitHub Security Scanning"
        uses: github/codeql-action/init@v3
        with:
          languages: javascript,python
          
      # SNYK LIMITADO: S√≥ roda em main pushes + schedule (ECONOMIA 75%)
      - name: "[SECURITY] Snyk Security Scan (Budget Controlled)"
        if: github.ref == 'refs/heads/main' && (github.event_name == 'push' || github.event_name == 'schedule')
        uses: snyk/actions/node@master
        continue-on-error: true  # N√£o falha se quota exceder
        env:
          SNYK_TOKEN: ${{ secrets.SNYK_TOKEN }}
        with:
          # Otimizado para vulnerabilidades CR√çTICAS apenas
          args: >
            --severity-threshold=high
            --policy-path=.snyk 
            --sarif-file-output=snyk.sarif
            --fail-on=upgradable
            --prune-repeated-subdependencies
          
      - name: "[SECURITY] Upload Snyk Results"
        uses: github/codeql-action/upload-sarif@v3
        if: always() && hashFiles('snyk.sarif') != '' && github.ref == 'refs/heads/main'
        with:
          sarif_file: snyk.sarif
          
      # FREE ALTERNATIVE: npm audit para PRs (sem limite)
      - name: "[SECURITY] NPM Audit (Gratuito)"
        if: github.event_name == 'pull_request' || github.ref != 'refs/heads/main'
        working-directory: apps/frontend-nextjs
        run: |
          echo "üîç Executando npm audit (gratuito)..."
          npm audit --audit-level=moderate --json | tee npm-audit.json || true
          
          # Conta vulnerabilidades cr√≠ticas
          if [ -f npm-audit.json ]; then
            CRITICAL=$(cat npm-audit.json | jq '.metadata.vulnerabilities.critical // 0')
            HIGH=$(cat npm-audit.json | jq '.metadata.vulnerabilities.high // 0')
            echo "‚ö†Ô∏è Vulnerabilidades encontradas: Cr√≠ticas: $CRITICAL, Altas: $HIGH"
          fi
        continue-on-error: true
          
      - name: "[SECURITY] CodeQL Analysis"
        uses: github/codeql-action/analyze@v3
        
      - name: "[NOTIFY] Security Status (Otimizado)"
        if: always() && (failure() || github.event_name == 'schedule')
        run: |
          SCAN_TYPE="üîí Scan agendado"
          if [ "${{ github.event_name }}" = "push" ]; then
            SCAN_TYPE="üöÄ Deploy PROD"
          fi
          
          if [ "${{ job.status }}" == "success" ]; then
            MESSAGE="‚úÖ [$SCAN_TYPE] Gates de seguran√ßa APROVADOS"
          else
            MESSAGE="‚ö†Ô∏è [$SCAN_TYPE] ALERTA: Falhas de seguran√ßa detectadas!"
          fi
          
          # S√≥ notifica falhas ou scans agendados (reduz spam)
          curl -s -X POST "https://api.telegram.org/bot$TELEGRAM_TOKEN/sendMessage" \
            -d chat_id="$TELEGRAM_CHAT_ID" \
            -d text="$MESSAGE"

  test-backend:
    name: "[TEST] Backend Tests"
    runs-on: ubuntu-latest
    needs: [detect-changes, security-quality-gates]
    if: needs.detect-changes.outputs.backend-changed == 'true' && inputs.skip_tests != true
    
    steps:
      - name: "[CHECKOUT] Checkout"
        uses: actions/checkout@v4
        
      - name: "[SETUP] Python Environment"
        uses: actions/setup-python@v4
        with:
          python-version: ${{ env.PYTHON_VERSION }}
          cache: 'pip'
          
      # CACHE OTIMIZADO: Multi-layer cache para m√°xima performance
      - name: "[CACHE] Python Dependencies (Otimizado)"
        uses: actions/cache@0c45773b623bea8c8e75f6c82b208c3cf94ea4f9  # v4.0.2
        with:
          path: |
            ~/.cache/pip
            ~/.local/lib/python*/site-packages
            apps/backend/.venv
            /opt/hostedtoolcache/Python
          key: prod-backend-${{ runner.os }}-py${{ env.PYTHON_VERSION }}-${{ hashFiles('apps/backend/requirements*.txt') }}
          restore-keys: |
            prod-backend-${{ runner.os }}-py${{ env.PYTHON_VERSION }}-
            prod-backend-${{ runner.os }}-
          
      - name: "[INSTALL] Backend Dependencies"
        working-directory: apps/backend
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt
          pip install pytest pytest-cov
          
      - name: "[TEST] Run Backend Tests"
        working-directory: apps/backend
        run: |
          echo "Executando testes do backend para PRODU√á√ÉO..."
          python -m pytest tests/ -v --cov=. --cov-report=xml
        continue-on-error: false  # TESTES OBRIGAT√ìRIOS em produ√ß√£o
          
      - name: "[COVERAGE] Upload Coverage"
        uses: codecov/codecov-action@v3
        with:
          file: apps/backend/coverage.xml
          flags: backend-prod

  test-frontend:
    name: "[TEST] Frontend Tests"
    runs-on: ubuntu-latest
    needs: [detect-changes, security-quality-gates]
    if: needs.detect-changes.outputs.frontend-changed == 'true' && inputs.skip_tests != true
    
    steps:
      - name: "[CHECKOUT] Checkout"
        uses: actions/checkout@v4
        
      - name: "[SETUP] Node.js Environment"
        uses: actions/setup-node@60edb5dd545a775178f52524783378180af0d1f8  # v4.0.2
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'
          cache-dependency-path: apps/frontend-nextjs/package-lock.json
          
      # CACHE ADICIONAL: Node modules + Next.js cache  
      - name: "[CACHE] Frontend Dependencies (Otimizado)"
        uses: actions/cache@0c45773b623bea8c8e75f6c82b208c3cf94ea4f9  # v4.0.2
        with:
          path: |
            apps/frontend-nextjs/node_modules
            apps/frontend-nextjs/.next/cache
            ~/.npm
          key: prod-frontend-${{ runner.os }}-node${{ env.NODE_VERSION }}-${{ hashFiles('apps/frontend-nextjs/package-lock.json') }}
          restore-keys: |
            prod-frontend-${{ runner.os }}-node${{ env.NODE_VERSION }}-
            prod-frontend-${{ runner.os }}-
          
      - name: "[INSTALL] Frontend Dependencies"
        working-directory: apps/frontend-nextjs
        run: |
          npm ci --production=false
          
      - name: "[BUILD] Frontend Build Test"
        working-directory: apps/frontend-nextjs
        run: |
          echo "Testando build do frontend para PRODUCAO..."
          npm run build
          
      - name: "[TEST] Frontend Tests"
        working-directory: apps/frontend-nextjs
        run: |
          echo "Executando testes do frontend para PRODU√á√ÉO..."
          npm test -- --coverage --watchAll=false
        continue-on-error: false  # TESTES OBRIGAT√ìRIOS em produ√ß√£o

  deploy-backend-prod:
    name: "[DEPLOY] Backend to Production"
    runs-on: ubuntu-latest
    needs: [detect-changes, security-quality-gates, test-backend]
    if: always() && (needs.detect-changes.outputs.backend-changed == 'true' && (needs.test-backend.result == 'success' || inputs.force_deploy == true))
    environment: production
    
    steps:
      - name: "[CHECKOUT] Checkout"
        uses: actions/checkout@v4
        
      - name: "[AUTH] Google Cloud Auth"
        uses: google-github-actions/auth@v2
        with:
          credentials_json: ${{ secrets.GCP_SA_KEY_PROD }}
          
      - name: "[SETUP] Cloud SDK"
        uses: google-github-actions/setup-gcloud@v2
        
      - name: "[DEPLOY] Backend to Cloud Run"
        working-directory: apps/backend
        run: |
          echo "Fazendo deploy do backend para PRODUCAO..."
          
          gcloud builds submit \
            --tag gcr.io/${{ secrets.GCP_PROJECT_ID_PROD }}/backend-prod:${{ github.sha }} \
            --project ${{ secrets.GCP_PROJECT_ID_PROD }}
          
          gcloud run deploy backend-prod \
            --image gcr.io/${{ secrets.GCP_PROJECT_ID_PROD }}/backend-prod:${{ github.sha }} \
            --platform managed \
            --region us-central1 \
            --allow-unauthenticated \
            --port=8080 \
            --memory 1Gi \
            --cpu 1 \
            --concurrency=100 \
            --max-instances 10 \
            --min-instances=0 \
            --timeout=300 \
            --set-env-vars="ENVIRONMENT=production,FLASK_ENV=production,DEBUG=false,SECRET_KEY=${{ secrets.SECRET_KEY }},OPENROUTER_API_KEY=${{ secrets.OPENROUTER_API_KEY }}" \
            --project ${{ secrets.GCP_PROJECT_ID_PROD }}
            
      # HEALTH CHECK COM RETRY INTELIGENTE
      - name: "[HEALTH] Backend Health Check (Retry Mechanism)"
        run: |
          echo "üîç Verificando sa√∫de do backend em PRODU√á√ÉO..."
          echo "Aguardando backend inicializar..."
          sleep 30
          
          BACKEND_URL=$(gcloud run services describe backend-prod --region=us-central1 --format="value(status.url)" --project ${{ secrets.GCP_PROJECT_ID_PROD }})
          
          HEALTH_OK=false
          for i in {1..30}; do
            if curl -f -s --max-time 10 "$BACKEND_URL/health" > /dev/null 2>&1; then
              echo "‚úÖ Backend em PRODU√á√ÉO est√° saud√°vel!"
              HEALTH_OK=true
              break
            fi
            echo "Tentativa $i/30 - Aguardando backend..."
            sleep 10
          done
          
          if [ "$HEALTH_OK" = "false" ]; then
            echo "‚ö†Ô∏è ERRO: Backend n√£o respondeu ap√≥s 5 minutos"
            exit 1
          fi
        timeout-minutes: 8  # Timeout total de 8 minutos
        continue-on-error: false  # Health check √© CR√çTICO

  deploy-frontend-prod:
    name: "[DEPLOY] Frontend to Production"
    runs-on: ubuntu-latest
    needs: [detect-changes, security-quality-gates, test-frontend, deploy-backend-prod]
    if: always() && (needs.detect-changes.outputs.frontend-changed == 'true' && (needs.test-frontend.result == 'success' || inputs.force_deploy == true))
    environment: production
    
    steps:
      - name: "[CHECKOUT] Checkout"
        uses: actions/checkout@v4
        
      - name: "[SETUP] Node.js"
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'
          cache-dependency-path: apps/frontend-nextjs/package-lock.json
          
      - name: "[INSTALL] Dependencies"
        working-directory: apps/frontend-nextjs
        run: npm ci
        
      - name: "[BUILD] Production Build"
        working-directory: apps/frontend-nextjs
        env:
          NEXT_PUBLIC_API_URL: ${{ secrets.PROD_API_URL }}
          NEXT_PUBLIC_ENVIRONMENT: production
        run: |
          echo "Buildando frontend para PRODUCAO..."
          npm run build
          
      - name: "[DEPLOY] Firebase Hosting"
        uses: FirebaseExtended/action-hosting-deploy@v0
        with:
          repoToken: ${{ secrets.GITHUB_TOKEN }}
          firebaseServiceAccount: ${{ secrets.FIREBASE_SERVICE_ACCOUNT_PROD }}
          projectId: ${{ secrets.FIREBASE_PROJECT_ID_PROD }}
          channelId: live
          entrypoint: apps/frontend-nextjs

  create-release:
    name: "[RELEASE] Criar Release de Producao"
    runs-on: ubuntu-latest
    needs: [deploy-backend-prod, deploy-frontend-prod]
    if: always() && (needs.deploy-backend-prod.result == 'success' || needs.deploy-frontend-prod.result == 'success')
    
    steps:
      - name: "[CHECKOUT] Checkout"
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          
      - name: "[RELEASE] Generate Version"
        id: version
        run: |
          TIMESTAMP=$(date +%Y%m%d-%H%M%S)
          COMMIT_SHORT=${GITHUB_SHA:0:7}
          VERSION="prod-v${TIMESTAMP}-${COMMIT_SHORT}"
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          
      - name: "[RELEASE] Create GitHub Release"
        uses: actions/create-release@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          tag_name: ${{ steps.version.outputs.version }}
          release_name: "Producao ${{ steps.version.outputs.version }}"
          body: |
            ## Release de Producao ${{ steps.version.outputs.version }}
            
            **Commit:** ${{ github.sha }}
            **Branch:** main
            **Ambiente:** Producao
            **Timestamp:** $(date)
            
            ### Mudancas Deployadas:
            - Backend: ${{ needs.deploy-backend-prod.result == 'success' && 'Sucesso' || 'N/A' }}
            - Frontend: ${{ needs.deploy-frontend-prod.result == 'success' && 'Sucesso' || 'N/A' }}
            
            ### Links:
            - Backend API: ${{ secrets.PROD_API_URL }}
            - Frontend: ${{ secrets.PROD_FRONTEND_URL }}
          draft: false
          prerelease: false

  notify-completion:
    name: "[NOTIFY] Notificacao Final"
    runs-on: ubuntu-latest
    needs: [deploy-backend-prod, deploy-frontend-prod, create-release]
    if: always()
    
    steps:
      - name: "[NOTIFY] Status Final"
        run: |
          BACKEND_STATUS="${{ needs.deploy-backend-prod.result }}"
          FRONTEND_STATUS="${{ needs.deploy-frontend-prod.result }}"
          RELEASE_STATUS="${{ needs.create-release.result }}"
          
          # NOTIFICA√á√ÉO CONSOLIDADA: S√≥ envia se houver mudan√ßas significativas
          SHOULD_NOTIFY=false
          
          if [ "$BACKEND_STATUS" == "success" ] || [ "$FRONTEND_STATUS" == "success" ]; then
            SHOULD_NOTIFY=true
            EMOJI="üöÄ"
            STATUS_TEXT="SUCESSO"
            MESSAGE="$EMOJI [PROD-$STATUS_TEXT] Deploy conclu√≠do!"
            MESSAGE="$MESSAGE%0Aüìä Resultados:"
            MESSAGE="$MESSAGE%0A‚Ä¢ Backend: $BACKEND_STATUS"
            MESSAGE="$MESSAGE%0A‚Ä¢ Frontend: $FRONTEND_STATUS" 
            MESSAGE="$MESSAGE%0A‚Ä¢ Release: $RELEASE_STATUS"
            MESSAGE="$MESSAGE%0A%0Aüîó Commit: ${GITHUB_SHA:0:7}"
          else
            SHOULD_NOTIFY=true  # Sempre notifica falhas
            EMOJI="üö®"
            STATUS_TEXT="ERRO"
            MESSAGE="$EMOJI [PROD-$STATUS_TEXT] Deploy FALHOU!"
            MESSAGE="$MESSAGE%0Aüí• Status:"
            MESSAGE="$MESSAGE%0A‚Ä¢ Backend: $BACKEND_STATUS"
            MESSAGE="$MESSAGE%0A‚Ä¢ Frontend: $FRONTEND_STATUS"
            MESSAGE="$MESSAGE%0A%0Aüîß A√ß√£o: Verificar logs imediatamente!"
          fi
          
          # Envia notifica√ß√£o apenas se necess√°rio
          if [ "$SHOULD_NOTIFY" = "true" ]; then
            curl -s -X POST "https://api.telegram.org/bot$TELEGRAM_TOKEN/sendMessage" \
              -d chat_id="$TELEGRAM_CHAT_ID" \
              -d text="$MESSAGE" \
              -d parse_mode="HTML" \
              -d disable_notification=${{ success() && 'true' || 'false' }} || echo "Falha na notifica√ß√£o (n√£o cr√≠tico)"
          fi

# CONCURRENCY OTIMIZADO: Cancela builds antigos para economizar recursos
concurrency:
  group: main-pipeline-${{ github.ref }}
  cancel-in-progress: ${{ github.event_name == 'pull_request' }}  # Cancela apenas PRs