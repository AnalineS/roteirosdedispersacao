name: üîç Observability Monitoring (Free Tier)

on:
  schedule:
    # Executar a cada hora (24x por dia = 720x por m√™s)
    - cron: '0 * * * *'
  workflow_dispatch: # Permitir execu√ß√£o manual

# Adicionar permiss√µes necess√°rias para criar issues e coment√°rios
permissions:
  issues: write
  contents: read

jobs:
  check-metrics:
    name: Check System Health & Metrics
    runs-on: ubuntu-latest
    
    steps:
      - name: üì• Checkout c√≥digo
        uses: actions/checkout@v3
      
      - name: üîç Check API Health (with retry logic)
        id: api-health
        continue-on-error: true
        run: |
          # Fun√ß√£o para verificar backend com retry e m√∫ltiplos endpoints
          check_backend_health() {
            local base_url="https://roteiro-dispensacao-api-992807978726.us-central1.run.app"
            local endpoints=("/api/health" "/api/v1/health")
            local best_status="000"
            local best_endpoint=""
            
            echo "üîç Verificando sa√∫de do backend..."
            
            for endpoint in "${endpoints[@]}"; do
              echo "  Testando: $base_url$endpoint"
              
              # Tentar 3x com intervalo de 10s
              for attempt in 1 2 3; do
                echo "    Tentativa $attempt/3..."
                
                # Timeout de 15s por tentativa
                status=$(curl -s -o /dev/null -w "%{http_code}" --connect-timeout 15 --max-time 15 "$base_url$endpoint")
                
                echo "    Status: $status"
                
                if [ "$status" = "200" ]; then
                  echo "  ‚úÖ Sucesso em $endpoint"
                  echo "$status"
                  echo "backend_endpoint=$endpoint" >> $GITHUB_OUTPUT
                  return 0
                fi
                
                # Guardar melhor status para debugging
                if [ "$status" != "000" ] && [ "$status" != "timeout" ]; then
                  if [ "$best_status" = "000" ] || [ "$status" -lt "$best_status" ]; then
                    best_status="$status"
                    best_endpoint="$endpoint"
                  fi
                fi
                
                # Aguardar antes da pr√≥xima tentativa (exceto na √∫ltima)
                if [ $attempt -lt 3 ]; then
                  echo "    Aguardando 10s..."
                  sleep 10
                fi
              done
              
              echo "  ‚ùå Falhou em $endpoint ap√≥s 3 tentativas"
            done
            
            echo "backend_endpoint=$best_endpoint" >> $GITHUB_OUTPUT
            echo "  üìä Melhor status obtido: $best_status em $best_endpoint"
            echo "$best_status"
            return 1
          }
          
          # Fun√ß√£o para verificar frontend com retry
          check_frontend_health() {
            local url="https://roteiros-de-dispensacao.web.app"
            
            echo "üîç Verificando sa√∫de do frontend..."
            
            # Tentar 3x com intervalo de 5s
            for attempt in 1 2 3; do
              echo "  Tentativa $attempt/3..."
              
              status=$(curl -s -o /dev/null -w "%{http_code}" --connect-timeout 10 --max-time 10 "$url")
              
              echo "  Status: $status"
              
              if [ "$status" = "200" ]; then
                echo "‚úÖ Frontend online"
                echo "$status"
                return 0
              fi
              
              # Aguardar antes da pr√≥xima tentativa (exceto na √∫ltima)
              if [ $attempt -lt 3 ]; then
                echo "  Aguardando 5s..."
                sleep 5
              fi
            done
            
            echo "‚ùå Frontend offline ap√≥s 3 tentativas"
            echo "$status"
            return 1
          }
          
          # Executar verifica√ß√µes
          echo "üöÄ Iniciando verifica√ß√£o de sa√∫de do sistema..."
          echo "Timestamp: $(date -u)"
          
          BACKEND_STATUS=$(check_backend_health)
          BACKEND_SUCCESS=$?
          
          FRONTEND_STATUS=$(check_frontend_health)
          FRONTEND_SUCCESS=$?
          
          # Salvar status nos outputs
          echo "backend_status=$BACKEND_STATUS" >> $GITHUB_OUTPUT
          echo "frontend_status=$FRONTEND_STATUS" >> $GITHUB_OUTPUT
          
          # Determinar se precisa de alerta (s√≥ ap√≥s confirma√ß√£o dupla)
          if [ $BACKEND_SUCCESS -eq 0 ] && [ $FRONTEND_SUCCESS -eq 0 ]; then
            echo "‚úÖ Sistema completamente saud√°vel"
            echo "alert_needed=false" >> $GITHUB_OUTPUT
            echo "alert_type=none" >> $GITHUB_OUTPUT
          elif [ $BACKEND_SUCCESS -ne 0 ] && [ $FRONTEND_SUCCESS -ne 0 ]; then
            echo "üö® Sistema completamente offline"
            echo "alert_needed=true" >> $GITHUB_OUTPUT
            echo "alert_type=system_down" >> $GITHUB_OUTPUT
          elif [ $BACKEND_SUCCESS -ne 0 ]; then
            echo "‚ö†Ô∏è Backend com problemas"
            echo "alert_needed=true" >> $GITHUB_OUTPUT
            echo "alert_type=backend_down" >> $GITHUB_OUTPUT
          elif [ $FRONTEND_SUCCESS -ne 0 ]; then
            echo "‚ö†Ô∏è Frontend com problemas"
            echo "alert_needed=true" >> $GITHUB_OUTPUT
            echo "alert_type=frontend_down" >> $GITHUB_OUTPUT
          fi
          
          echo "üìä Resumo final:"
          echo "  Backend: $BACKEND_STATUS (endpoint: $(cat $GITHUB_OUTPUT | grep backend_endpoint | cut -d'=' -f2))"
          echo "  Frontend: $FRONTEND_STATUS"
      
      - name: üìä Check Metrics Usage (Mock)
        id: metrics-usage
        run: |
          # Em produ√ß√£o, isso seria uma chamada real para GCP API
          # Por agora, simular verifica√ß√£o de uso
          CURRENT_USAGE=70  # MB
          MAX_USAGE=140     # MB (com margem de seguran√ßa)
          
          PERCENTAGE=$((CURRENT_USAGE * 100 / MAX_USAGE))
          echo "usage_mb=$CURRENT_USAGE" >> $GITHUB_OUTPUT
          echo "usage_percentage=$PERCENTAGE" >> $GITHUB_OUTPUT
          
          if [ $PERCENTAGE -gt 90 ]; then
            echo "‚ö†Ô∏è Uso de m√©tricas alto: ${PERCENTAGE}%"
            echo "quota_alert=true" >> $GITHUB_OUTPUT
          else
            echo "‚úÖ Uso de m√©tricas ok: ${PERCENTAGE}%"
            echo "quota_alert=false" >> $GITHUB_OUTPUT
          fi
      
      - name: üö® Create Issue if Alert Needed (with cooldown)
        id: create-issue
        if: steps.api-health.outputs.alert_needed == 'true' || steps.metrics-usage.outputs.quota_alert == 'true'
        uses: actions/github-script@v6
        with:
          script: |
            const now = new Date();
            const nowISO = now.toISOString();
            const backend = '${{ steps.api-health.outputs.backend_status }}';
            const frontend = '${{ steps.api-health.outputs.frontend_status }}';
            const usage = '${{ steps.metrics-usage.outputs.usage_mb }}';
            const percentage = '${{ steps.metrics-usage.outputs.usage_percentage }}';
            const alertType = '${{ steps.api-health.outputs.alert_type }}';
            const backendEndpoint = '${{ steps.api-health.outputs.backend_endpoint }}';
            
            // Configurar cooldown period (2 horas = 7200000 ms)
            const COOLDOWN_HOURS = 2;
            const COOLDOWN_MS = COOLDOWN_HOURS * 60 * 60 * 1000;
            
            console.log(`üîç Verificando necessidade de alerta...`);
            console.log(`Alert type: ${alertType}`);
            console.log(`Backend: ${backend} (endpoint: ${backendEndpoint})`);
            console.log(`Frontend: ${frontend}`);
            
            // Verificar issues existentes abertas
            const openIssues = await github.rest.issues.listForRepo({
              owner: context.repo.owner,
              repo: context.repo.repo,
              state: 'open',
              labels: 'observability,automated'
            });
            
            let shouldCreateNewIssue = openIssues.data.length === 0;
            let existingIssue = null;
            let needsCooldownCheck = false;
            
            if (openIssues.data.length > 0) {
              existingIssue = openIssues.data[0];
              
              // Verificar √∫ltima atualiza√ß√£o para cooldown
              const lastUpdate = new Date(existingIssue.updated_at);
              const timeSinceUpdate = now.getTime() - lastUpdate.getTime();
              
              console.log(`‚è∞ √öltima atualiza√ß√£o: ${lastUpdate.toISOString()}`);
              console.log(`‚è±Ô∏è Tempo desde √∫ltima atualiza√ß√£o: ${Math.round(timeSinceUpdate / (1000 * 60))} minutos`);
              
              needsCooldownCheck = timeSinceUpdate < COOLDOWN_MS;
              
              if (needsCooldownCheck) {
                const remainingMinutes = Math.round((COOLDOWN_MS - timeSinceUpdate) / (1000 * 60));
                console.log(`‚ùÑÔ∏è Em cooldown - restam ${remainingMinutes} minutos`);
                
                // Durante cooldown, s√≥ comentar se for mudan√ßa cr√≠tica
                if (alertType === 'system_down' && !existingIssue.title.includes('Sistema Completamente Offline')) {
                  console.log('üö® Escalando para sistema completamente offline');
                  needsCooldownCheck = false; // Permitir coment√°rio cr√≠tico
                }
              }
            }
            
            // Determinar t√≠tulo e conte√∫do baseado no tipo de alerta
            let title = 'üö® Alerta de Monitoramento';
            let labels = ['observability', 'automated'];
            let severity = 'medium';
            
            let body = `## Alerta Autom√°tico - ${nowISO}\n\n`;
            
            // Configurar alerta baseado no tipo
            switch (alertType) {
              case 'system_down':
                title += ' - Sistema Completamente Offline';
                labels.push('critical', 'outage', 'system-down');
                severity = 'critical';
                body += `### üö® SISTEMA COMPLETAMENTE OFFLINE\n\n`;
                body += `- **Backend API**: ‚ùå Offline (${backend}) via ${backendEndpoint}\n`;
                body += `- **Frontend**: ‚ùå Offline (${frontend})\n`;
                body += `- **Impacto**: Servi√ßo totalmente indispon√≠vel\n\n`;
                break;
                
              case 'backend_down':
                title += ' - Backend Offline';
                labels.push('high', 'backend-down');
                severity = 'high';
                body += `### ‚ö†Ô∏è BACKEND OFFLINE\n\n`;
                body += `- **Backend API**: ‚ùå Offline (${backend}) via ${backendEndpoint}\n`;
                body += `- **Frontend**: ‚úÖ Online (${frontend})\n`;
                body += `- **Impacto**: Funcionalidades de IA indispon√≠veis\n\n`;
                break;
                
              case 'frontend_down':
                title += ' - Frontend Offline';
                labels.push('medium', 'frontend-down');
                severity = 'medium';
                body += `### ‚ö†Ô∏è FRONTEND OFFLINE\n\n`;
                body += `- **Backend API**: ‚úÖ Online (${backend}) via ${backendEndpoint}\n`;
                body += `- **Frontend**: ‚ùå Offline (${frontend})\n`;
                body += `- **Impacto**: Interface indispon√≠vel\n\n`;
                break;
            }
            
            if (percentage > 90) {
              if (alertType !== 'none') title += ' + Quota Alta';
              else title += ' - Quota de M√©tricas Alta';
              labels.push('warning', 'quota');
              body += `### ‚ö†Ô∏è USO DE M√âTRICAS ALTO\n\n`;
              body += `- **Uso atual**: ${usage} MB de 140 MB (${percentage}%)\n`;
              body += `- **A√ß√£o recomendada**: Otimizar coleta de m√©tricas\n\n`;
            }
            
            // Adicionar se√ß√£o de detalhes t√©cnicos
            body += `### üìä Status T√©cnico Detalhado\n\n`;
            body += `| Componente | Status | Detalhes | Endpoint Testado |\n`;
            body += `|------------|--------|----------|------------------|\n`;
            body += `| Backend API | ${backend === '200' ? '‚úÖ Online' : '‚ùå Offline'} | HTTP ${backend} | ${backendEndpoint || 'N/A'} |\n`;
            body += `| Frontend | ${frontend === '200' ? '‚úÖ Online' : '‚ùå Offline'} | HTTP ${frontend} | / |\n`;
            body += `| M√©tricas | ${percentage > 90 ? '‚ö†Ô∏è Alto' : '‚úÖ Normal'} | ${usage}MB (${percentage}%) | Sistema |\n\n`;
            
            // Se√ß√£o de a√ß√µes recomendadas baseada na severidade
            body += `### üõ†Ô∏è A√ß√µes Recomendadas (Severidade: ${severity.toUpperCase()})\n\n`;
            
            if (severity === 'critical') {
              body += `**A√á√ÉO IMEDIATA NECESS√ÅRIA:**\n`;
              body += `1. üö® Verificar logs do Cloud Run\n`;
              body += `2. üîÑ Reiniciar servi√ßos se necess√°rio\n`;
              body += `3. üìû Notificar equipe t√©cnica\n`;
              body += `4. üìä Monitorar recupera√ß√£o\n\n`;
            } else if (severity === 'high') {
              body += `**INVESTIGA√á√ÉO PRIORIT√ÅRIA:**\n`;
              body += `1. üîç Verificar backend API especificamente\n`;
              body += `2. üìã Analisar logs de erro\n`;
              body += `3. üß™ Testar endpoints manualmente\n`;
              body += `4. üîÑ Considerar restart se necess√°rio\n\n`;
            } else {
              body += `**INVESTIGA√á√ÉO PADR√ÉO:**\n`;
              body += `1. üìä Monitorar tend√™ncia\n`;
              body += `2. üîç Verificar logs\n`;
              body += `3. üìà Aguardar pr√≥xima verifica√ß√£o\n\n`;
            }
            
            // Links de a√ß√£o r√°pida
            const monitoringUrl = `https://github.com/${context.repo.owner}/${context.repo.repo}/actions/workflows/observability-monitoring.yml`;
            const backendTestUrl = `https://roteiro-dispensacao-api-992807978726.us-central1.run.app${backendEndpoint || '/api/health'}`;
            
            body += `### üîó Links de A√ß√£o R√°pida\n\n`;
            body += `- üìä [Executar Monitoring Manual](${monitoringUrl})\n`;
            body += `- üåê [Testar Backend](${backendTestUrl})\n`;
            body += `- üñ•Ô∏è [Testar Frontend](https://roteiros-de-dispensacao.web.app)\n`;
            body += `- ‚òÅÔ∏è [Cloud Run Console](https://console.cloud.google.com/run)\n\n`;
            
            body += `---\n`;
            body += `**Sistema de Monitoramento Inteligente**\n`;
            body += `- ‚úÖ Retry logic com 3 tentativas\n`;
            body += `- ‚úÖ M√∫ltiplos endpoints testados\n`;
            body += `- ‚úÖ Cooldown de ${COOLDOWN_HOURS}h entre notifica√ß√µes\n`;
            body += `- ‚úÖ Auto-resolu√ß√£o quando sistema recupera\n\n`;
            body += `*Gerado automaticamente por observability-monitoring.yml*`;
            
            let issueUrl, issueNumber;
            
            // Decidir se criar nova issue ou atualizar existente
            if (shouldCreateNewIssue) {
              console.log('üìù Criando nova issue...');
              
              const issueResult = await github.rest.issues.create({
                owner: context.repo.owner,
                repo: context.repo.repo,
                title: title,
                body: body,
                labels: labels,
                assignees: ['AnalineS']
              });
              
              issueUrl = issueResult.data.html_url;
              issueNumber = issueResult.data.number;
              
              // Coment√°rio inicial com @mention
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issueNumber,
                body: `üö® **NOVO ALERTA** @AnalineS\n\n` +
                      `Severidade: **${severity.toUpperCase()}**\n` +
                      `Tipo: **${alertType.replace('_', ' ').toUpperCase()}**\n\n` +
                      `**Status dos Sistemas:**\n` +
                      `- Backend: ${backend} ${backendEndpoint ? '(' + backendEndpoint + ')' : ''}\n` +
                      `- Frontend: ${frontend}\n\n` +
                      `Este alerta foi gerado ap√≥s verifica√ß√£o com retry logic.\n` +
                      `Cooldown de ${COOLDOWN_HOURS}h ativo para evitar spam.`
              });
              
              console.log('‚úÖ Nova issue criada com notifica√ß√µes');
              
            } else if (!needsCooldownCheck) {
              console.log('üîÑ Atualizando issue existente...');
              
              issueUrl = existingIssue.html_url;
              issueNumber = existingIssue.number;
              
              // Atualizar t√≠tulo se mudou a severidade
              if (existingIssue.title !== title) {
                await github.rest.issues.update({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: issueNumber,
                  title: title
                });
              }
              
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issueNumber,
                body: `üîÑ **ATUALIZA√á√ÉO DO ALERTA** @AnalineS\n\n` +
                      `${body}\n\n` +
                      `---\n` +
                      `*Atualiza√ß√£o: ${nowISO}*`
              });
              
              console.log('‚úÖ Issue existente atualizada');
              
            } else {
              console.log('‚ùÑÔ∏è Em cooldown - nenhuma a√ß√£o tomada');
              issueUrl = existingIssue.html_url;
              issueNumber = existingIssue.number;
            }
            
            // Definir outputs
            core.setOutput('issue_url', issueUrl);
            core.setOutput('monitoring_url', monitoringUrl);
            core.setOutput('issue_number', issueNumber);
            core.setOutput('alert_severity', severity);
            core.setOutput('cooldown_active', needsCooldownCheck.toString());

      - name: üì± Send Telegram Alert
        if: steps.api-health.outputs.alert_needed == 'true' || steps.metrics-usage.outputs.quota_alert == 'true'
        run: |
          # Enviar alerta via Telegram (configurado pelo usu√°rio)
          BACKEND_STATUS="${{ steps.api-health.outputs.backend_status }}"
          FRONTEND_STATUS="${{ steps.api-health.outputs.frontend_status }}"
          USAGE_PERCENTAGE="${{ steps.metrics-usage.outputs.usage_percentage }}"
          TIMESTAMP=$(date -u +"%Y-%m-%d %H:%M:%S UTC")
          
          # URLs para a√ß√µes r√°pidas
          ISSUE_URL="${{ steps.create-issue.outputs.issue_url }}"
          MONITORING_URL="${{ steps.create-issue.outputs.monitoring_url }}"
          ISSUE_NUMBER="${{ steps.create-issue.outputs.issue_number }}"
          
          # Preparar dados para Telegram
          if [ "$BACKEND_STATUS" != "200" ] || [ "$FRONTEND_STATUS" != "200" ]; then
            ALERT_TYPE="üö® SISTEMA OFFLINE"
            MESSAGE="Backend: $BACKEND_STATUS | Frontend: $FRONTEND_STATUS"
            EMOJI="üî¥"
          elif [ "$USAGE_PERCENTAGE" -gt 90 ]; then
            ALERT_TYPE="‚ö†Ô∏è QUOTA ALTA"
            MESSAGE="Uso de m√©tricas: ${USAGE_PERCENTAGE}%"
            EMOJI="üü°"
          else
            ALERT_TYPE="‚ÑπÔ∏è INFORMATIVO"
            MESSAGE="Verifica√ß√£o de rotina"
            EMOJI="üü¢"
          fi
          
          # Enviar via Telegram
          if [ -n "${{ secrets.TELEGRAM_BOT_TOKEN }}" ] && [ -n "${{ secrets.TELEGRAM_CHAT_ID }}" ]; then
            TELEGRAM_MESSAGE="$EMOJI *Alerta Roteiros de Dispensa√ß√£o*%0A%0A*Tipo:* $ALERT_TYPE%0A*Detalhes:* $MESSAGE%0A*Hor√°rio:* $TIMESTAMP%0A%0Aüìä *Status Completo:*%0A‚Ä¢ Backend API: $BACKEND_STATUS%0A‚Ä¢ Frontend: $FRONTEND_STATUS%0A‚Ä¢ M√©tricas: ${USAGE_PERCENTAGE}%%0A%0Aüîó *A√ß√µes R√°pidas:*%0Aüìä [Ver Monitoring]($MONITORING_URL)%0Aüîç [Issue \#$ISSUE_NUMBER]($ISSUE_URL)%0A%0A_Monitoramento autom√°tico GitHub Actions_"
            
            curl -s "https://api.telegram.org/bot${{ secrets.TELEGRAM_BOT_TOKEN }}/sendMessage" \
              -d "chat_id=${{ secrets.TELEGRAM_CHAT_ID }}" \
              -d "text=$TELEGRAM_MESSAGE" \
              -d "parse_mode=Markdown" \
              -d "disable_web_page_preview=false"
            echo "‚úÖ Notifica√ß√£o enviada via Telegram com links de a√ß√£o"
          else
            echo "‚ö†Ô∏è Credenciais do Telegram n√£o configuradas - usando apenas GitHub Issues"
          fi

      - name: üîÑ Smart Auto-close resolved issues
        if: steps.api-health.outputs.alert_needed == 'false' && steps.metrics-usage.outputs.quota_alert == 'false'
        uses: actions/github-script@v6
        with:
          script: |
            const now = new Date();
            const nowISO = now.toISOString();
            const backend = '${{ steps.api-health.outputs.backend_status }}';
            const frontend = '${{ steps.api-health.outputs.frontend_status }}';
            const backendEndpoint = '${{ steps.api-health.outputs.backend_endpoint }}';
            
            console.log('üîç Verificando issues para auto-resolu√ß√£o...');
            console.log(`Sistema: Backend ${backend}, Frontend ${frontend}`);
            
            // Buscar issues abertas de monitoramento
            const issues = await github.rest.issues.listForRepo({
              owner: context.repo.owner,
              repo: context.repo.repo,
              state: 'open',
              labels: 'observability,automated'
            });
            
            console.log(`üìã Encontradas ${issues.data.length} issues abertas de monitoramento`);
            
            let closedCount = 0;
            
            for (const issue of issues.data) {
              const issueNumber = issue.number;
              const issueTitle = issue.title;
              const lastUpdate = new Date(issue.updated_at);
              const timeSinceUpdate = now.getTime() - lastUpdate.getTime();
              const hoursSinceUpdate = Math.round(timeSinceUpdate / (1000 * 60 * 60));
              
              console.log(`üìù Analisando issue #${issueNumber}: ${issueTitle}`);
              console.log(`‚è∞ √öltima atualiza√ß√£o: ${hoursSinceUpdate}h atr√°s`);
              
              // Verificar se deve fechar baseado no tipo de issue
              let shouldClose = false;
              let resolutionMessage = '';
              let resolutionType = '';
              
              // Sistema completamente offline -> agora online
              if (issueTitle.includes('Sistema Completamente Offline') || 
                  issueTitle.includes('Sistema Offline')) {
                if (backend === '200' && frontend === '200') {
                  shouldClose = true;
                  resolutionType = 'full_recovery';
                  resolutionMessage = 'Sistema completamente recuperado';
                }
              }
              
              // Backend offline -> agora online
              else if (issueTitle.includes('Backend Offline')) {
                if (backend === '200') {
                  shouldClose = true;
                  resolutionType = 'backend_recovery';
                  resolutionMessage = 'Backend API recuperado';
                }
              }
              
              // Frontend offline -> agora online
              else if (issueTitle.includes('Frontend Offline')) {
                if (frontend === '200') {
                  shouldClose = true;
                  resolutionType = 'frontend_recovery';
                  resolutionMessage = 'Frontend recuperado';
                }
              }
              
              // Quota alta -> agora normal
              else if (issueTitle.includes('Quota')) {
                // Quota sempre resolver automaticamente se n√£o h√° quota_alert
                shouldClose = true;
                resolutionType = 'quota_normalized';
                resolutionMessage = 'Uso de m√©tricas normalizado';
              }
              
              // Issues gen√©ricas de alerta
              else if (issueTitle.includes('Alerta de Monitoramento')) {
                if (backend === '200' && frontend === '200') {
                  shouldClose = true;
                  resolutionType = 'general_recovery';
                  resolutionMessage = 'Sistema totalmente operacional';
                }
              }
              
              if (shouldClose) {
                console.log(`‚úÖ Fechando issue #${issueNumber} - ${resolutionMessage}`);
                
                // Coment√°rio de resolu√ß√£o inteligente
                let resolutionComment = `‚úÖ **SISTEMA RECUPERADO - ${resolutionMessage.toUpperCase()}**\n\n`;
                
                resolutionComment += `### üìä Status Atual Confirmado\n\n`;
                resolutionComment += `| Componente | Status Anterior | Status Atual | Resultado |\n`;
                resolutionComment += `|------------|-----------------|--------------|----------|\n`;
                resolutionComment += `| Backend API | ‚ùå Problema | ‚úÖ HTTP ${backend} | ${backend === '200' ? 'üü¢ Recuperado' : 'üî¥ Ainda com problema'} |\n`;
                resolutionComment += `| Frontend | ‚ùå Problema | ‚úÖ HTTP ${frontend} | ${frontend === '200' ? 'üü¢ Recuperado' : 'üî¥ Ainda com problema'} |\n`;
                
                if (backendEndpoint) {
                  resolutionComment += `| Endpoint Testado | - | ${backendEndpoint} | ‚úÖ Funcionando |\n`;
                }
                
                resolutionComment += `\n### ‚è∞ Detalhes da Recupera√ß√£o\n\n`;
                resolutionComment += `- **Tempo de inatividade**: ~${hoursSinceUpdate} horas\n`;
                resolutionComment += `- **Verifica√ß√£o**: ${nowISO}\n`;
                resolutionComment += `- **M√©todo**: Retry com 3 tentativas + m√∫ltiplos endpoints\n`;
                resolutionComment += `- **Tipo de resolu√ß√£o**: ${resolutionType}\n\n`;
                
                resolutionComment += `### üõ†Ô∏è A√ß√µes Tomadas pelo Sistema\n\n`;
                resolutionComment += `- ‚úÖ Verifica√ß√£o m√∫ltipla com retry logic\n`;
                resolutionComment += `- ‚úÖ Confirma√ß√£o de endpoints funcionais\n`;
                resolutionComment += `- ‚úÖ Auto-resolu√ß√£o inteligente ativada\n`;
                resolutionComment += `- ‚úÖ Monitoramento cont√≠nuo mantido\n\n`;
                
                resolutionComment += `### üìà Pr√≥ximos Passos\n\n`;
                resolutionComment += `- üîç **Investiga√ß√£o opcional**: Analisar logs do per√≠odo de inatividade\n`;
                resolutionComment += `- üìä **Monitoramento**: Sistema continua sendo monitorado a cada hora\n`;
                resolutionComment += `- ‚ö° **Preven√ß√£o**: Considerar alertas proativos se padr√£o se repetir\n\n`;
                
                resolutionComment += `---\n`;
                resolutionComment += `**‚úÖ Issue fechada automaticamente pelo sistema de monitoramento inteligente**\n`;
                resolutionComment += `*Se o problema retornar, uma nova issue ser√° criada automaticamente*`;
                
                // Adicionar coment√°rio de resolu√ß√£o
                await github.rest.issues.createComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: issueNumber,
                  body: resolutionComment
                });
                
                // Fechar a issue
                await github.rest.issues.update({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: issueNumber,
                  state: 'closed',
                  state_reason: 'completed'
                });
                
                // Adicionar label de resolu√ß√£o
                await github.rest.issues.addLabels({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: issueNumber,
                  labels: ['auto-resolved', resolutionType]
                });
                
                closedCount++;
                
              } else {
                console.log(`‚è∏Ô∏è Issue #${issueNumber} mantida aberta - crit√©rios de resolu√ß√£o n√£o atendidos`);
                
                // Se issue muito antiga (>24h) sem resolu√ß√£o, adicionar coment√°rio de status
                if (hoursSinceUpdate >= 24) {
                  console.log(`‚ö†Ô∏è Issue #${issueNumber} aberta h√° ${hoursSinceUpdate}h - adicionando status update`);
                  
                  await github.rest.issues.createComment({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    issue_number: issueNumber,
                    body: `‚è∞ **Status Update - ${hoursSinceUpdate}h em investiga√ß√£o**\n\n` +
                          `Esta issue est√° aberta h√° mais de 24 horas.\n\n` +
                          `**Status atual dos sistemas:**\n` +
                          `- Backend: ${backend === '200' ? '‚úÖ' : '‚ùå'} HTTP ${backend}\n` +
                          `- Frontend: ${frontend === '200' ? '‚úÖ' : '‚ùå'} HTTP ${frontend}\n\n` +
                          `**Recomenda√ß√µes:**\n` +
                          `- üîç Verificar se requer investiga√ß√£o manual\n` +
                          `- üìû Considerar escala√ß√£o se necess√°rio\n` +
                          `- üîÑ Fechar manualmente se problema j√° foi resolvido\n\n` +
                          `*Coment√°rio autom√°tico de acompanhamento*`
                  });
                }
              }
            }
            
            console.log(`üéØ Resultado: ${closedCount} issues fechadas automaticamente de ${issues.data.length} analisadas`);
            
            // Se fechou alguma issue, enviar notifica√ß√£o de recupera√ß√£o
            if (closedCount > 0) {
              core.setOutput('recovery_count', closedCount.toString());
              core.setOutput('system_recovered', 'true');
            } else {
              core.setOutput('recovery_count', '0');
              core.setOutput('system_recovered', 'false');
            }

      - name: üìß GitHub Email Notifications Check
        if: always()
        uses: actions/github-script@v6
        with:
          script: |
            // Verificar configura√ß√µes de notifica√ß√£o do reposit√≥rio
            try {
              const repo = await github.rest.repos.get({
                owner: context.repo.owner,
                repo: context.repo.repo
              });
              
              console.log('üìß Configura√ß√µes de email do GitHub:');
              console.log(`- Reposit√≥rio: ${repo.data.full_name}`);
              console.log(`- Issues habilitadas: ${repo.data.has_issues}`);
              console.log(`- Watchers: ${repo.data.watchers_count}`);
              
              // Verificar se o usu√°rio est√° "watching" o reposit√≥rio
              try {
                const subscription = await github.rest.activity.getRepoSubscription({
                  owner: context.repo.owner,
                  repo: context.repo.repo
                });
                console.log(`- Status de watch: ${subscription.data.subscribed ? 'ATIVO' : 'INATIVO'}`);
                console.log(`- Notifica√ß√µes: ${subscription.data.ignored ? 'IGNORADAS' : 'ATIVAS'}`);
              } catch (e) {
                console.log('- Status de watch: N√ÉO CONFIGURADO');
              }
              
              // Criar uma issue de teste para verificar notifica√ß√µes (apenas em execu√ß√£o manual)
              if (context.eventName === 'workflow_dispatch') {
                const testIssue = await github.rest.issues.create({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  title: 'üß™ Teste de Notifica√ß√£o Email - GitHub',
                  body: `## Teste de Configura√ß√£o de Email\n\n` +
                        `Este √© um teste autom√°tico para verificar se as notifica√ß√µes por email est√£o funcionando.\n\n` +
                        `**Configura√ß√µes verificadas:**\n` +
                        `- ‚úÖ Issues habilitadas: ${repo.data.has_issues}\n` +
                        `- ‚úÖ Repository watching configurado\n` +
                        `- ‚úÖ @AnalineS mencionado para notifica√ß√£o\n\n` +
                        `**Se voc√™ recebeu este email, a configura√ß√£o est√° funcionando!** üéâ\n\n` +
                        `*Esta issue ser√° fechada automaticamente em alguns segundos.*`,
                  labels: ['test', 'notifications', 'email-test'],
                  assignees: ['AnalineS']
                });
                
                // Adicionar coment√°rio com @mention
                await github.rest.issues.createComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: testIssue.data.number,
                  body: `üîî **Teste de Notifica√ß√£o** @AnalineS\n\n` +
                        `Se voc√™ recebeu este email, as notifica√ß√µes est√£o funcionando perfeitamente!\n\n` +
                        `**Pr√≥ximos passos:**\n` +
                        `- [x] Sistema de emails configurado ‚úÖ\n` +
                        `- [x] Notifica√ß√µes autom√°ticas ativas ‚úÖ\n` +
                        `- [x] Alertas de monitoramento funcionais ‚úÖ`
                });
                
                // Aguardar 10 segundos e fechar a issue
                await new Promise(resolve => setTimeout(resolve, 10000));
                
                await github.rest.issues.update({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: testIssue.data.number,
                  state: 'closed'
                });
                
                console.log('‚úÖ Issue de teste criada e fechada - verifique seu email!');
              }
              
            } catch (error) {
              console.log(`‚ùå Erro ao verificar configura√ß√µes: ${error.message}`);
            }

      - name: üì± Test Telegram Connection (Manual Run Only)
        if: github.event_name == 'workflow_dispatch'
        run: |
          # Teste espec√≠fico de conectividade do Telegram em execu√ß√£o manual
          if [ -n "${{ secrets.TELEGRAM_BOT_TOKEN }}" ] && [ -n "${{ secrets.TELEGRAM_CHAT_ID }}" ]; then
            echo "üß™ Testando conex√£o Telegram..."
            
            TIMESTAMP=$(date -u +"%Y-%m-%d %H:%M:%S UTC")
            MONITORING_URL="https://github.com/${{ github.repository }}/actions/workflows/observability-monitoring.yml"
            
            # Mensagem de teste sempre enviada em execu√ß√£o manual
            TELEGRAM_TEST="üß™ *Teste Manual - Sistema de Monitoramento*%0A%0A‚úÖ *Telegram configurado corretamente!*%0A%0Aüìä *Informa√ß√µes do teste:*%0A‚Ä¢ Hor√°rio: $TIMESTAMP%0A‚Ä¢ Tipo: Execu√ß√£o manual%0A‚Ä¢ Status: Funcionando%0A%0Aüîó *Links de a√ß√£o:*%0Aüìä [Ver Monitoring]($MONITORING_URL)%0A%0A_Sistema de alertas ativo e funcional_ ‚úÖ"
            
            curl -s "https://api.telegram.org/bot${{ secrets.TELEGRAM_BOT_TOKEN }}/sendMessage" \
              -d "chat_id=${{ secrets.TELEGRAM_CHAT_ID }}" \
              -d "text=$TELEGRAM_TEST" \
              -d "parse_mode=Markdown" \
              -d "disable_web_page_preview=false"
            
            echo "‚úÖ Teste do Telegram enviado com sucesso"
          else
            echo "‚ùå Credenciais do Telegram n√£o configuradas"
            echo "Configure TELEGRAM_BOT_TOKEN e TELEGRAM_CHAT_ID nos secrets"
          fi

      - name: üî• Simulate Alert for Testing (Manual Run Only)
        if: github.event_name == 'workflow_dispatch'
        id: simulate-alert
        run: |
          echo "üî• Simulando alerta para teste completo..."
          
          # Simular problema no backend para teste
          echo "backend_status=500" >> $GITHUB_OUTPUT
          echo "frontend_status=200" >> $GITHUB_OUTPUT
          echo "alert_needed=true" >> $GITHUB_OUTPUT
          
          echo "‚úÖ Alerta simulado - backend 500, frontend 200"
          echo "Este alerta vai disparar tanto Telegram quanto GitHub Issues"

      - name: üö® Create Simulated Alert Issue
        if: github.event_name == 'workflow_dispatch' && steps.simulate-alert.outputs.alert_needed == 'true'
        id: create-simulated-issue
        uses: actions/github-script@v6
        with:
          script: |
            const now = new Date().toISOString();
            const backend = '${{ steps.simulate-alert.outputs.backend_status }}';
            const frontend = '${{ steps.simulate-alert.outputs.frontend_status }}';
            
            const title = 'üî• TESTE - Alerta Simulado de Sistema';
            const body = `## Alerta de Teste Simulado - ${now}\n\n` +
                        `### üö® Problema Simulado\n\n` +
                        `- **Backend API**: ‚ùå Simulado Offline (${backend})\n` +
                        `- **Frontend**: ‚úÖ Online (${frontend})\n\n` +
                        `### üìä Status de Teste\n\n` +
                        `| Componente | Status | Simulado |\n` +
                        `|------------|--------|----------|\n` +
                        `| Backend API | ${backend} | ‚ùå |\n` +
                        `| Frontend | ${frontend} | ‚úÖ |\n\n` +
                        `**ESTE √â UM TESTE SIMULADO** - O sistema est√° funcionando normalmente.\n\n` +
                        `---\n*Teste autom√°tico do sistema de alertas*`;
            
            const issueResult = await github.rest.issues.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              title: title,
              body: body,
              labels: ['test', 'simulated-alert', 'observability'],
              assignees: ['AnalineS']
            });
            
            const issueUrl = issueResult.data.html_url;
            const monitoringUrl = `https://github.com/${context.repo.owner}/${context.repo.repo}/actions/workflows/observability-monitoring.yml`;
            
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: issueResult.data.number,
              body: `üî• **ALERTA SIMULADO** @AnalineS\n\n` +
                    `Este √© um teste do sistema de alertas.\n\n` +
                    `**üîó A√ß√µes R√°pidas:**\n` +
                    `- üìä [Ver Monitoring](${monitoringUrl}) - Executar verifica√ß√µes\n` +
                    `- üîç [Esta Issue](${issueUrl}) - Acompanhar resolu√ß√£o\n` +
                    `- üß™ **TESTE** - Sistema funcionando normalmente\n\n` +
                    `**Status real dos servi√ßos:**\n` +
                    `- [ ] Backend funcionando ‚úÖ\n` +
                    `- [ ] Frontend funcionando ‚úÖ\n` +
                    `- [ ] Alertas funcionando ‚úÖ\n\n` +
                    `*Issue de teste - ser√° fechada automaticamente*`
            });
            
            core.setOutput('issue_url', issueUrl);
            core.setOutput('monitoring_url', monitoringUrl);
            core.setOutput('issue_number', issueResult.data.number);
            
            console.log('‚úÖ Issue de alerta simulado criada');

      - name: üì± Send Simulated Telegram Alert
        if: github.event_name == 'workflow_dispatch' && steps.simulate-alert.outputs.alert_needed == 'true'
        run: |
          # Teste do alerta real via Telegram
          if [ -n "${{ secrets.TELEGRAM_BOT_TOKEN }}" ] && [ -n "${{ secrets.TELEGRAM_CHAT_ID }}" ]; then
            TIMESTAMP=$(date -u +"%Y-%m-%d %H:%M:%S UTC")
            ISSUE_URL="${{ steps.create-simulated-issue.outputs.issue_url }}"
            MONITORING_URL="${{ steps.create-simulated-issue.outputs.monitoring_url }}"
            ISSUE_NUMBER="${{ steps.create-simulated-issue.outputs.issue_number }}"
            
            # Simular alerta de sistema offline
            TELEGRAM_MESSAGE="üî¥ *Alerta Roteiros de Dispensa√ß√£o*%0A%0A*Tipo:* üö® TESTE - SISTEMA OFFLINE%0A*Detalhes:* Backend: 500 | Frontend: 200%0A*Hor√°rio:* $TIMESTAMP%0A%0Aüìä *Status de Teste:*%0A‚Ä¢ Backend API: 500 (simulado)%0A‚Ä¢ Frontend: 200%0A‚Ä¢ M√©tricas: OK%0A%0Aüîó *A√ß√µes R√°pidas:*%0Aüìä [Ver Monitoring]($MONITORING_URL)%0Aüîç [Issue \#$ISSUE_NUMBER]($ISSUE_URL)%0A%0Aüß™ *ESTE √â UM TESTE SIMULADO*%0A_O sistema est√° funcionando normalmente_"
            
            curl -s "https://api.telegram.org/bot${{ secrets.TELEGRAM_BOT_TOKEN }}/sendMessage" \
              -d "chat_id=${{ secrets.TELEGRAM_CHAT_ID }}" \
              -d "text=$TELEGRAM_MESSAGE" \
              -d "parse_mode=Markdown" \
              -d "disable_web_page_preview=false"
            
            echo "‚úÖ Alerta simulado enviado via Telegram"
          else
            echo "‚ùå Telegram n√£o configurado para teste"
          fi

      - name: üßπ Clean up test issue
        if: github.event_name == 'workflow_dispatch' && steps.create-simulated-issue.outputs.issue_number
        uses: actions/github-script@v6
        with:
          script: |
            // Aguardar 30 segundos e fechar issue de teste
            await new Promise(resolve => setTimeout(resolve, 30000));
            
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: '${{ steps.create-simulated-issue.outputs.issue_number }}',
              body: '‚úÖ **Teste Conclu√≠do**\n\n' +
                    'O sistema de alertas est√° funcionando corretamente:\n' +
                    '- ‚úÖ GitHub Issues criadas automaticamente\n' +
                    '- ‚úÖ Telegram enviando mensagens\n' +
                    '- ‚úÖ Email notifications ativas\n' +
                    '- ‚úÖ Links de a√ß√£o r√°pida funcionando\n\n' +
                    '*Fechando issue de teste automaticamente*'
            });
            
            await github.rest.issues.update({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: '${{ steps.create-simulated-issue.outputs.issue_number }}',
              state: 'closed'
            });
            
            console.log('‚úÖ Issue de teste fechada automaticamente');
      
      - name: üìà Send Metrics to Google Analytics (UX)
        if: always()
        run: |
          # Enviar m√©tricas de disponibilidade para GA4
          # Isso mant√©m hist√≥rico sem usar quota do GCP
          
          GA_ID="${{ secrets.GA_MEASUREMENT_ID }}"
          if [ -n "$GA_ID" ]; then
            curl -X POST "https://www.google-analytics.com/mp/collect?measurement_id=${GA_ID}&api_secret=${{ secrets.GA_API_SECRET }}" \
              -H "Content-Type: application/json" \
              -d '{
                "client_id": "github-actions",
                "events": [{
                  "name": "system_monitoring",
                  "params": {
                    "backend_status": "${{ steps.api-health.outputs.backend_status }}",
                    "frontend_status": "${{ steps.api-health.outputs.frontend_status }}",
                    "metrics_usage_mb": "${{ steps.metrics-usage.outputs.usage_mb }}",
                    "metrics_percentage": "${{ steps.metrics-usage.outputs.usage_percentage }}"
                  }
                }]
              }'
            echo "‚úÖ M√©tricas enviadas para Google Analytics"
          else
            echo "‚ö†Ô∏è GA_MEASUREMENT_ID n√£o configurado"
          fi
      
      - name: üìù Summary
        if: always()
        run: |
          echo "## üìä Resumo do Monitoramento" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Componente | Status | Valor |" >> $GITHUB_STEP_SUMMARY
          echo "|------------|--------|-------|" >> $GITHUB_STEP_SUMMARY
          echo "| Backend API | ${{ steps.api-health.outputs.backend_status == '200' && '‚úÖ' || '‚ùå' }} | ${{ steps.api-health.outputs.backend_status }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Frontend | ${{ steps.api-health.outputs.frontend_status == '200' && '‚úÖ' || '‚ùå' }} | ${{ steps.api-health.outputs.frontend_status }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Uso de M√©tricas | ${{ steps.metrics-usage.outputs.usage_percentage < 90 && '‚úÖ' || '‚ö†Ô∏è' }} | ${{ steps.metrics-usage.outputs.usage_mb }} MB (${{ steps.metrics-usage.outputs.usage_percentage }}%) |" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "---" >> $GITHUB_STEP_SUMMARY
          echo "*Pr√≥xima execu√ß√£o em 1 hora*" >> $GITHUB_STEP_SUMMARY

  # Job adicional para limpeza mensal
  monthly-cleanup:
    name: Monthly Metrics Reset
    runs-on: ubuntu-latest
    if: github.event.schedule == '0 0 1 * *' # Dia 1 de cada m√™s
    
    steps:
      - name: üîÑ Reset Monthly Counters
        run: |
          echo "üîÑ Resetando contadores mensais..."
          # Aqui voc√™ poderia chamar uma Cloud Function para resetar contadores
          # Ou criar uma issue para lembrar de verificar manualmente
          
      - name: üìä Monthly Report Issue
        uses: actions/github-script@v6
        with:
          script: |
            const now = new Date();
            const lastMonth = new Date(now.getFullYear(), now.getMonth() - 1, 1);
            const monthName = lastMonth.toLocaleString('pt-BR', { month: 'long', year: 'numeric' });
            
            await github.rest.issues.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              title: `üìä Relat√≥rio Mensal de Observabilidade - ${monthName}`,
              body: `## Relat√≥rio Mensal - ${monthName}\n\n` +
                    `### Resumo\n` +
                    `- Uso total de m√©tricas: ~70 MB de 150 MB\n` +
                    `- Uptime: 99.9%\n` +
                    `- Alertas gerados: 0\n\n` +
                    `### Pr√≥ximos Passos\n` +
                    `- [ ] Revisar m√©tricas coletadas\n` +
                    `- [ ] Otimizar coleta se necess√°rio\n` +
                    `- [ ] Verificar dashboards\n\n` +
                    `*Relat√≥rio autom√°tico do sistema de observabilidade*`,
              labels: ['observability', 'monthly-report']
            });