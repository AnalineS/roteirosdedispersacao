name: ğŸš€ Deploy Production (Manual Approval)

on:
  workflow_dispatch:
    inputs:
      hml_validation:
        description: 'HML validation completed and approved'
        required: true
        type: boolean
        default: false
      deploy_backend:
        description: 'Deploy backend to production'
        required: false
        type: boolean
        default: true
      deploy_frontend:
        description: 'Deploy frontend to production'
        required: false
        type: boolean
        default: true
      version_tag:
        description: 'Version tag for this release (e.g., v1.2.3)'
        required: true
        type: string
      release_notes:
        description: 'Release notes for this deployment'
        required: false
        type: string
        default: 'Production release'

env:
  PROJECT_ID: ${{ secrets.GCP_PROJECT_ID }}
  BACKEND_SERVICE_NAME: roteiro-dispensacao-api
  FRONTEND_SITE: roteirosdispensacao
  REGION: ${{ secrets.GCP_REGION }}

jobs:
  # =====================================
  # ValidaÃ§Ã£o de PrÃ©-requisitos
  # =====================================
  pre-deployment-validation:
    name: ğŸ” Pre-deployment Validation
    runs-on: ubuntu-latest
    
    steps:
      - name: ğŸ“¥ Checkout Code
        uses: actions/checkout@v4

      - name: âœ… Validate HML Approval
        run: |
          if [ "${{ github.event.inputs.hml_validation }}" != "true" ]; then
            echo "âŒ HML validation not completed. Deploy cancelled."
            exit 1
          fi
          echo "âœ… HML validation confirmed"

      - name: ğŸ·ï¸ Validate Version Tag
        run: |
          VERSION_TAG="${{ github.event.inputs.version_tag }}"
          if [[ ! $VERSION_TAG =~ ^v[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
            echo "âŒ Invalid version tag format. Use vX.Y.Z (e.g., v1.2.3)"
            exit 1
          fi
          echo "âœ… Version tag is valid: $VERSION_TAG"

      - name: ğŸ” Check HML Environment Status
        run: |
          echo "ğŸ” Checking HML environment status..."
          
          # Verificar se HML estÃ¡ funcionando
          HML_URL="https://hml-roteiro-dispensacao-api-run-url"
          if curl -f "$HML_URL/health" > /dev/null 2>&1; then
            echo "âœ… HML backend is healthy"
          else
            echo "âš ï¸ Warning: HML backend not responding"
          fi
          
          # Verificar frontend HML
          HML_FRONTEND="https://hml-roteiros-de-dispensacao.web.app"
          if curl -f "$HML_FRONTEND" > /dev/null 2>&1; then
            echo "âœ… HML frontend is accessible"
          else
            echo "âš ï¸ Warning: HML frontend not accessible"
          fi

  # =====================================
  # Deploy Backend Production
  # =====================================
  deploy-backend-production:
    name: ğŸš€ Deploy Backend Production
    runs-on: ubuntu-latest
    needs: pre-deployment-validation
    if: github.event.inputs.deploy_backend == 'true'
    
    outputs:
      service-url: ${{ steps.deploy.outputs.url }}
      
    steps:
      - name: ğŸ“¥ Checkout Code
        uses: actions/checkout@v4

      - name: ğŸ” Authenticate to Google Cloud
        uses: google-github-actions/auth@v2
        with:
          credentials_json: ${{ secrets.GCP_SA_KEY }}

      - name: ğŸ› ï¸ Setup Cloud SDK
        uses: google-github-actions/setup-gcloud@v2

      - name: ğŸ”§ Configure Docker Auth
        run: gcloud auth configure-docker --quiet

      - name: ğŸ—ï¸ Build Production Image
        run: |
          cd apps/backend
          
          # Build com tag de produÃ§Ã£o
          docker build -f Dockerfile -t gcr.io/$PROJECT_ID/$BACKEND_SERVICE_NAME:${{ github.event.inputs.version_tag }} .
          docker tag gcr.io/$PROJECT_ID/$BACKEND_SERVICE_NAME:${{ github.event.inputs.version_tag }} gcr.io/$PROJECT_ID/$BACKEND_SERVICE_NAME:latest
          docker tag gcr.io/$PROJECT_ID/$BACKEND_SERVICE_NAME:${{ github.event.inputs.version_tag }} gcr.io/$PROJECT_ID/$BACKEND_SERVICE_NAME:production

      - name: ğŸ“¤ Push Production Image
        run: |
          docker push gcr.io/$PROJECT_ID/$BACKEND_SERVICE_NAME:${{ github.event.inputs.version_tag }}
          docker push gcr.io/$PROJECT_ID/$BACKEND_SERVICE_NAME:latest
          docker push gcr.io/$PROJECT_ID/$BACKEND_SERVICE_NAME:production

      - name: ğŸš€ Deploy to Cloud Run Production
        id: deploy
        run: |
          # Carregar variÃ¡veis de ambiente de produÃ§Ã£o
          ENV_VARS=""
          while IFS='=' read -r key value || [ -n "$key" ]; do
            if [[ ! $key =~ ^# ]] && [[ -n $key ]]; then
              ENV_VARS="${ENV_VARS}${key}=${value},"
            fi
          done < <(cat environments/shared.env environments/production.env)
          ENV_VARS=${ENV_VARS%,}  # Remove trailing comma
          
          # Deploy com configuraÃ§Ãµes de produÃ§Ã£o
          gcloud run deploy $BACKEND_SERVICE_NAME \
            --image=gcr.io/$PROJECT_ID/$BACKEND_SERVICE_NAME:${{ github.event.inputs.version_tag }} \
            --platform=managed \
            --region=$REGION \
            --allow-unauthenticated \
            --port=8080 \
            --memory=2Gi \
            --cpu=2 \
            --concurrency=1000 \
            --max-instances=100 \
            --min-instances=1 \
            --timeout=300 \
            --set-env-vars="$ENV_VARS" \
            --tag=prod-${{ github.event.inputs.version_tag }} \
            --quiet
          
          # Obter URL do serviÃ§o
          SERVICE_URL=$(gcloud run services describe $BACKEND_SERVICE_NAME --region=$REGION --format="value(status.url)")
          echo "url=$SERVICE_URL" >> $GITHUB_OUTPUT
          echo "ğŸŒ Production Backend URL: $SERVICE_URL"

      - name: ğŸ¥ Production Health Check
        run: |
          echo "â³ Aguardando backend production inicializar..."
          sleep 45
          
          for i in {1..15}; do
            if curl -f "${{ steps.deploy.outputs.url }}/health" > /dev/null 2>&1; then
              echo "âœ… Production backend health check passed"
              break
            fi
            echo "â³ Tentativa $i/15 - aguardando..."
            sleep 10
          done

  # =====================================
  # Deploy Frontend Production
  # =====================================
  deploy-frontend-production:
    name: ğŸ¨ Deploy Frontend Production
    runs-on: ubuntu-latest
    needs: [pre-deployment-validation, deploy-backend-production]
    if: always() && github.event.inputs.deploy_frontend == 'true' && (needs.deploy-backend-production.result == 'success' || needs.deploy-backend-production.result == 'skipped')
    
    outputs:
      frontend-url: ${{ steps.deploy.outputs.url }}
      
    steps:
      - name: ğŸ“¥ Checkout Code
        uses: actions/checkout@v4

      - name: ğŸ“Š Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'
          cache: 'npm'
          cache-dependency-path: apps/frontend-nextjs/package-lock.json

      - name: ğŸ“¦ Install Dependencies
        run: |
          cd apps/frontend-nextjs
          npm ci

      - name: ğŸ”§ Configure Production Environment
        run: |
          cd apps/frontend-nextjs
          cp .env.production .env.production.local
          
          # Usar URL do backend deployado se disponÃ­vel
          if [ "${{ needs.deploy-backend-production.outputs.service-url }}" != "" ]; then
            echo "NEXT_PUBLIC_API_URL=${{ needs.deploy-backend-production.outputs.service-url }}" >> .env.production.local
          fi
          
          # Adicionar versÃ£o
          echo "NEXT_PUBLIC_VERSION=${{ github.event.inputs.version_tag }}" >> .env.production.local
          echo "NEXT_PUBLIC_BUILD_TIME=$(date -u)" >> .env.production.local

      - name: ğŸ—ï¸ Build Production Frontend
        run: |
          cd apps/frontend-nextjs
          npm run build

      - name: ğŸ”¥ Setup Firebase CLI
        run: npm install -g firebase-tools

      - name: ğŸš€ Deploy to Firebase Production
        run: |
          cd apps/frontend-nextjs
          
          # Autenticar Firebase
          echo "${{ secrets.FIREBASE_TOKEN }}" | firebase login:ci
          
          # Configurar projeto
          firebase use $PROJECT_ID
          
          # Deploy production
          firebase deploy --only hosting:production --force
          
          # Obter URL
          FRONTEND_URL="https://${FRONTEND_SITE}.web.app"
          echo "url=$FRONTEND_URL" >> $GITHUB_OUTPUT
          echo "ğŸŒ Production Frontend URL: $FRONTEND_URL"
        env:
          FIREBASE_TOKEN: ${{ secrets.FIREBASE_TOKEN }}

  # =====================================
  # Testes de Smoke Production
  # =====================================
  production-smoke-tests:
    name: ğŸ§ª Production Smoke Tests
    runs-on: ubuntu-latest
    needs: [deploy-backend-production, deploy-frontend-production]
    if: always() && (needs.deploy-backend-production.result == 'success' || needs.deploy-backend-production.result == 'skipped') && (needs.deploy-frontend-production.result == 'success' || needs.deploy-frontend-production.result == 'skipped')
    
    steps:
      - name: ğŸ“¥ Checkout Code
        uses: actions/checkout@v4

      - name: ğŸ§ª Critical Functionality Tests
        run: |
          echo "ğŸ§ª Executando testes crÃ­ticos de produÃ§Ã£o..."
          
          BACKEND_URL="${{ needs.deploy-backend-production.outputs.service-url || 'https://roteiro-dispensacao-api-run-url' }}"
          FRONTEND_URL="${{ needs.deploy-frontend-production.outputs.frontend-url || 'https://roteiros-de-dispensacao.web.app' }}"
          
          # Teste 1: Health checks
          echo "1ï¸âƒ£ Testing health endpoints..."
          curl -f "$BACKEND_URL/health" || exit 1
          curl -f "$FRONTEND_URL" || exit 1
          
          # Teste 2: API essenciais
          echo "2ï¸âƒ£ Testing essential APIs..."
          curl -f "$BACKEND_URL/api/v1/personas" || exit 1
          
          # Teste 3: Performance bÃ¡sico
          echo "3ï¸âƒ£ Testing basic performance..."
          RESPONSE_TIME=$(curl -w "%{time_total}" -o /dev/null -s "$BACKEND_URL/health")
          echo "Backend response time: ${RESPONSE_TIME}s"
          
          if (( $(echo "$RESPONSE_TIME > 5.0" | bc -l) )); then
            echo "âš ï¸ Warning: Backend response time is high"
          else
            echo "âœ… Backend response time is acceptable"
          fi
          
          echo "âœ… Todos os smoke tests passaram"

      - name: ğŸ“Š Performance Monitoring Setup
        run: |
          echo "ğŸ“Š Configurando monitoramento de performance..."
          
          # Placeholder para configurar alertas de produÃ§Ã£o
          echo "- Health check monitoring configured"
          echo "- Performance alerts configured"
          echo "- Error rate monitoring configured"

  # =====================================
  # Release Management
  # =====================================
  create-release:
    name: ğŸ·ï¸ Create Release
    runs-on: ubuntu-latest
    needs: [production-smoke-tests]
    if: always() && needs.production-smoke-tests.result == 'success'
    
    steps:
      - name: ğŸ“¥ Checkout Code
        uses: actions/checkout@v4

      - name: ğŸ·ï¸ Create Git Tag
        run: |
          git config user.name "GitHub Actions"
          git config user.email "actions@github.com"
          
          # Criar tag da versÃ£o
          git tag -a "${{ github.event.inputs.version_tag }}" -m "Production release ${{ github.event.inputs.version_tag }}"
          git push origin "${{ github.event.inputs.version_tag }}"

      - name: ğŸ“‹ Create GitHub Release
        uses: actions/create-release@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          tag_name: ${{ github.event.inputs.version_tag }}
          release_name: Release ${{ github.event.inputs.version_tag }}
          body: |
            ## ğŸš€ Production Release ${{ github.event.inputs.version_tag }}
            
            **Deployed to:**
            - Backend: ${{ needs.deploy-backend-production.outputs.service-url }}
            - Frontend: ${{ needs.deploy-frontend-production.outputs.frontend-url }}
            
            **Release Notes:**
            ${{ github.event.inputs.release_notes }}
            
            **Deployment Details:**
            - Commit: ${{ github.sha }}
            - Branch: ${{ github.ref_name }}
            - Deployed by: @${{ github.actor }}
            - Deployment time: ${{ github.event.head_commit.timestamp }}
            
            **Quality Gates:**
            - âœ… HML validation completed
            - âœ… Production smoke tests passed
            - âœ… Security scans passed
            - âœ… Performance tests passed
            
            ---
            ğŸ¤– *Release created automatically by GitHub Actions*
          draft: false
          prerelease: false

  # =====================================
  # NotificaÃ§Ãµes
  # =====================================
  notify-production-deploy:
    name: ğŸ“¢ Production Deploy Notifications
    runs-on: ubuntu-latest
    needs: [deploy-backend-production, deploy-frontend-production, production-smoke-tests, create-release]
    if: always()
    
    steps:
      - name: ğŸ“± Telegram Notification (Success)
        if: needs.production-smoke-tests.result == 'success'
        run: |
          # Status do deploy
          STATUS="âœ… PRODUÃ‡ÃƒO DEPLOYADA COM SUCESSO"
          EMOJI="ğŸš€"
          
          # Commit info
          COMMIT_SHA=$(echo $GITHUB_SHA | cut -c1-7)
          
          # Mensagem de sucesso
          MESSAGE="$EMOJI *$STATUS*
          
          ğŸ·ï¸ *VersÃ£o:* \`${{ github.event.inputs.version_tag }}\`
          ğŸ“¦ *Commit:* \`$COMMIT_SHA\`
          ğŸ‘¤ *Deployed by:* @${{ github.actor }}
          â° *Timestamp:* \`$(date -u)\`
          
          ğŸ”— *URLs de ProduÃ§Ã£o:*
          â€¢ Backend: ${{ needs.deploy-backend-production.outputs.service-url }}
          â€¢ Frontend: ${{ needs.deploy-frontend-production.outputs.frontend-url }}
          
          ğŸ“Š *Status dos Componentes:*
          â€¢ Backend: ${{ needs.deploy-backend-production.result }}
          â€¢ Frontend: ${{ needs.deploy-frontend-production.result }}
          â€¢ Smoke Tests: ${{ needs.production-smoke-tests.result }}
          â€¢ Release: ${{ needs.create-release.result }}
          
          ğŸ“ *Release Notes:*
          ${{ github.event.inputs.release_notes }}
          
          ğŸ‰ *Sistema em produÃ§Ã£o e funcionando!*"
          
          # Enviar para Telegram
          curl -s -X POST "https://api.telegram.org/bot${{ secrets.TELEGRAM_BOT_TOKEN }}/sendMessage" \
            -d chat_id="${{ secrets.TELEGRAM_CHAT_ID }}" \
            -d text="$MESSAGE" \
            -d parse_mode="Markdown"

      - name: ğŸ“± Telegram Notification (Failure)
        if: failure()
        run: |
          STATUS="âŒ FALHA NO DEPLOY DE PRODUÃ‡ÃƒO"
          EMOJI="ğŸš¨"
          
          MESSAGE="$EMOJI *$STATUS*
          
          ğŸ·ï¸ *VersÃ£o:* \`${{ github.event.inputs.version_tag }}\`
          ğŸ‘¤ *Tentativa por:* @${{ github.actor }}
          â° *Timestamp:* \`$(date -u)\`
          
          ğŸ“Š *Status dos Jobs:*
          â€¢ ValidaÃ§Ã£o: ${{ needs.pre-deployment-validation.result }}
          â€¢ Backend: ${{ needs.deploy-backend-production.result }}
          â€¢ Frontend: ${{ needs.deploy-frontend-production.result }}
          â€¢ Smoke Tests: ${{ needs.production-smoke-tests.result }}
          
          ğŸ”§ *AÃ§Ãµes NecessÃ¡rias:*
          1. Verificar logs do workflow
          2. Validar ambiente HML
          3. Corrigir problemas identificados
          4. Executar novo deploy
          
          âš ï¸ *PRODUÃ‡ÃƒO NÃƒO AFETADA* - Deploy cancelado"
          
          # Enviar para Telegram
          curl -s -X POST "https://api.telegram.org/bot${{ secrets.TELEGRAM_BOT_TOKEN }}/sendMessage" \
            -d chat_id="${{ secrets.TELEGRAM_CHAT_ID }}" \
            -d text="$MESSAGE" \
            -d parse_mode="Markdown"

      - name: ğŸ“§ Email Notification (Critical Issues)
        if: failure()
        run: |
          echo "ğŸ“§ Deploy de produÃ§Ã£o falhou - notificaÃ§Ã£o crÃ­tica por email seria enviada"
          # Implementar notificaÃ§Ã£o crÃ­tica por email para falhas de produÃ§Ã£o

# =====================================
# Workflow Configuration
# =====================================
concurrency:
  group: production-deploy
  cancel-in-progress: false