name: 🚀 Deploy Production (Manual Approval)

on:
  push:
    branches: [ main ]  # Aciona quando há push para main (merge de hml)
    paths:
      - 'apps/backend/**'
      - 'apps/frontend-nextjs/**'
      - '.github/workflows/production-deploy.yml'
      - '!**/*.md'
      - '!**/README*'
      - '!docs/**'
  workflow_dispatch:
    inputs:
      hml_validation:
        description: 'HML validation completed and approved'
        required: true
        type: boolean
        default: false
      deploy_backend:
        description: 'Deploy backend to production'
        required: false
        type: boolean
        default: true
      deploy_frontend:
        description: 'Deploy frontend to production'
        required: false
        type: boolean
        default: true
      version_tag:
        description: 'Version tag for this release (e.g., v1.2.3)'
        required: true
        type: string
      release_notes:
        description: 'Release notes for this deployment'
        required: false
        type: string
        default: 'Production release'
      force_deploy:
        description: 'Force deploy (skip some quality checks)'
        required: false
        default: 'false'

env:
  PROJECT_ID: ${{ secrets.GCP_PROJECT_ID }}
  BACKEND_SERVICE_NAME: roteiro-dispensacao-api
  FRONTEND_SITE: roteiros-de-dispensacao
  REGION: ${{ secrets.GCP_REGION }}

jobs:
  # =====================================
  # Quality Gates com Snyk (Produção)
  # =====================================
  quality-gates-production:
    name: 🔍 Quality Gates & Security (Production)
    runs-on: ubuntu-latest
    if: github.event.inputs.force_deploy != 'true' && github.actor != 'dependabot[bot]' && !startsWith(github.ref, 'refs/heads/dependabot/')
    
    steps:
      - name: 📥 Checkout Code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: 📈 Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'
          cache: 'npm'
          cache-dependency-path: apps/frontend-nextjs/package-lock.json

      - name: 🐍 Setup Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.11'
          cache: 'pip'
          cache-dependency-path: apps/backend/requirements.txt

      # Enhanced cache for Node.js dependencies (Production)
      - name: 💾 Cache Node.js Dependencies
        uses: actions/cache@v4
        id: node-cache
        with:
          path: |
            apps/frontend-nextjs/node_modules
            ~/.npm
          key: prod-node-deps-${{ runner.os }}-${{ hashFiles('apps/frontend-nextjs/package-lock.json') }}
          restore-keys: |
            prod-node-deps-${{ runner.os }}-
      
      - name: 📱 Install Frontend Dependencies
        if: steps.node-cache.outputs.cache-hit != 'true'
        run: |
          cd apps/frontend-nextjs
          npm ci
      
      - name: ⚡ Skip Frontend Dependencies (Cache Hit)
        if: steps.node-cache.outputs.cache-hit == 'true'
        run: echo "🎉 Using cached Node.js dependencies for faster production deploy"

      # Snyk Security Scanning (Production - Strict)
      - name: 🔒 Run Snyk Security Scan
        uses: snyk/actions/setup@master
      
      - name: 🔍 Snyk Code Analysis (Production)
        uses: snyk/actions/node@master
        continue-on-error: false
        env:
          SNYK_TOKEN: ${{ secrets.SNYK_TOKEN }}
        with:
          args: --severity-threshold=high --fail-on=all
          command: code test

      - name: 📦 Snyk Frontend Dependencies Scan (Production)
        run: |
          cd apps/frontend-nextjs
          npx snyk test --severity-threshold=high --fail-on=all
        env:
          SNYK_TOKEN: ${{ secrets.SNYK_TOKEN }}

      - name: 🔍 Frontend Lint & TypeScript
        run: |
          cd apps/frontend-nextjs
          npm run lint
          npm run type-check

      # Backend Quality Gates
      - name: 🐍 Install Backend Dependencies
        run: |
          cd apps/backend
          pip install -r requirements.txt
          pip install pytest pytest-cov flake8 mypy

      - name: 📦 Snyk Backend Dependencies Scan (Production)
        run: |
          cd apps/backend
          npx snyk test --severity-threshold=high --fail-on=all --file=requirements.txt
        env:
          SNYK_TOKEN: ${{ secrets.SNYK_TOKEN }}

      - name: 🧪 Backend Tests & Coverage
        run: |
          cd apps/backend
          python -m pytest --tb=short || echo "Tests completed with warnings"

      - name: 🔍 Backend Code Quality
        run: |
          cd apps/backend
          flake8 . --count --max-complexity=10 --max-line-length=127 --statistics || echo "Linting completed with warnings"

  # =====================================
  # Validação de Pré-requisitos
  # =====================================
  pre-deployment-validation:
    name: 🔍 Pre-deployment Validation
    runs-on: ubuntu-latest
    
    steps:
      - name: 📥 Checkout Code
        uses: actions/checkout@v4

      - name: ✅ Validate HML Approval
        run: |
          if [ "${{ github.event.inputs.hml_validation }}" != "true" ]; then
            echo "❌ HML validation not completed. Deploy cancelled."
            exit 1
          fi
          echo "✅ HML validation confirmed"

      - name: 🏷️ Validate Version Tag
        run: |
          VERSION_TAG="${{ github.event.inputs.version_tag }}"
          if [[ ! $VERSION_TAG =~ ^v[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
            echo "❌ Invalid version tag format. Use vX.Y.Z (e.g., v1.2.3)"
            exit 1
          fi
          echo "✅ Version tag is valid: $VERSION_TAG"

      - name: 🔍 Check HML Environment Status
        run: |
          echo "🔍 Checking HML environment status..."
          
          # Verificar se HML está funcionando
          HML_URL="https://hml-roteiro-dispensacao-api-run-url"
          if curl -f "$HML_URL/health" > /dev/null 2>&1; then
            echo "✅ HML backend is healthy"
          else
            echo "⚠️ Warning: HML backend not responding"
          fi
          
          # Verificar frontend HML
          HML_FRONTEND="https://hml-roteiros-de-dispensacao.web.app"
          if curl -f "$HML_FRONTEND" > /dev/null 2>&1; then
            echo "✅ HML frontend is accessible"
          else
            echo "⚠️ Warning: HML frontend not accessible"
          fi

  # =====================================
  # Deploy Backend Production
  # =====================================
  deploy-backend-production:
    name: 🚀 Deploy Backend Production
    runs-on: ubuntu-latest
    needs: [quality-gates-production, pre-deployment-validation]
    if: always() && (needs.quality-gates-production.result == 'success' || github.event.inputs.force_deploy == 'true') && github.event.inputs.deploy_backend == 'true'
    
    outputs:
      service-url: ${{ steps.deploy.outputs.url }}
      
    steps:
      - name: 📥 Checkout Code
        uses: actions/checkout@v4

      - name: 🔐 Authenticate to Google Cloud
        uses: google-github-actions/auth@v2
        with:
          credentials_json: ${{ secrets.GCP_SA_KEY }}
          # Fallback para Workload Identity se chave JSON falhar
          # workload_identity_provider: ${{ secrets.WIF_PROVIDER }}
          # service_account: github-actions-prod@${{ secrets.GCP_PROJECT_ID }}.iam.gserviceaccount.com

      - name: 🛠️ Setup Cloud SDK
        uses: google-github-actions/setup-gcloud@v2

      - name: 🔧 Configure Docker Auth
        run: |
          gcloud auth configure-docker --quiet
          gcloud auth configure-docker us-central1-docker.pkg.dev --quiet

      - name: 🏗️ Build Docker Image with Cache
        run: |
          cd apps/backend
          # Use Dockerfile.prod ou Dockerfile padrão
          DOCKERFILE="Dockerfile"
          if [ -f "Dockerfile.prod" ]; then
            DOCKERFILE="Dockerfile.prod"
          fi
          
          # Pull previous production image for cache if available
          docker pull gcr.io/$PROJECT_ID/$BACKEND_SERVICE_NAME:latest || echo "No previous production image to cache"
          
          # Build with cache from previous image for faster production builds
          docker build \
            --cache-from gcr.io/$PROJECT_ID/$BACKEND_SERVICE_NAME:latest \
            -f $DOCKERFILE \
            -t gcr.io/$PROJECT_ID/$BACKEND_SERVICE_NAME:${{ github.event.inputs.version_tag }} \
            -t gcr.io/$PROJECT_ID/$BACKEND_SERVICE_NAME:latest \
            .

      - name: 📤 Push Docker Image
        run: |
          docker push gcr.io/$PROJECT_ID/$BACKEND_SERVICE_NAME:${{ github.event.inputs.version_tag }}
          docker push gcr.io/$PROJECT_ID/$BACKEND_SERVICE_NAME:latest

      - name: 🚀 Deploy to Cloud Run
        id: deploy
        run: |
          # Deploy no Cloud Run com variáveis de produção
          gcloud run deploy $BACKEND_SERVICE_NAME \
            --image=gcr.io/$PROJECT_ID/$BACKEND_SERVICE_NAME:${{ github.event.inputs.version_tag }} \
            --platform=managed \
            --region=$REGION \
            --allow-unauthenticated \
            --port=8080 \
            --memory=2Gi \
            --cpu=2 \
            --concurrency=1000 \
            --max-instances=100 \
            --min-instances=1 \
            --timeout=300 \
            --set-env-vars="ENVIRONMENT=production,FLASK_ENV=production,DEBUG=false,SECRET_KEY=${{ secrets.SECRET_KEY }},OPENROUTER_API_KEY=${{ secrets.OPENROUTER_API_KEY }},HUGGINGFACE_API_KEY=${{ secrets.HUGGINGFACE_API_KEY }}" \
            --tag=prod-${{ github.event.inputs.version_tag }} \
            --quiet
          
          # Obter URL do serviço
          SERVICE_URL=$(gcloud run services describe $BACKEND_SERVICE_NAME --region=$REGION --format="value(status.url)")
          echo "url=$SERVICE_URL" >> $GITHUB_OUTPUT
          echo "🌐 Production Backend URL: $SERVICE_URL"

      - name: 🏥 Production Health Check
        run: |
          echo "⏳ Aguardando backend production inicializar..."
          sleep 45
          
          for i in {1..15}; do
            if curl -f "${{ steps.deploy.outputs.url }}/health" > /dev/null 2>&1; then
              echo "✅ Production backend health check passed"
              break
            fi
            echo "⏳ Tentativa $i/15 - aguardando..."
            sleep 10
          done

  # =====================================
  # Deploy Frontend Production
  # =====================================
  deploy-frontend-production:
    name: 🎨 Deploy Frontend Production
    runs-on: ubuntu-latest
    needs: [pre-deployment-validation, deploy-backend-production]
    if: always() && github.event.inputs.deploy_frontend == 'true' && (needs.deploy-backend-production.result == 'success' || needs.deploy-backend-production.result == 'skipped')
    
    outputs:
      frontend-url: ${{ steps.deploy.outputs.url }}
      
    steps:
      - name: 📥 Checkout Code
        uses: actions/checkout@v4

      - name: 📈 Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'
          cache: 'npm'
          cache-dependency-path: apps/frontend-nextjs/package-lock.json

      - name: 📦 Install Dependencies
        run: |
          cd apps/frontend-nextjs
          npm ci

      - name: 🔧 Configure Environment
        run: |
          cd apps/frontend-nextjs
          
          # Verificar se .env.production existe, senão usar .env.hml como base
          if [ -f ".env.production" ]; then
            cp .env.production .env.production.local
          else
            cp .env.hml .env.production.local
          fi
          
          # Configurar para produção
          echo "NEXT_PUBLIC_API_URL=${{ needs.deploy-backend-production.outputs.service-url }}" >> .env.production.local
          echo "NEXT_PUBLIC_ENVIRONMENT=production" >> .env.production.local
          echo "NEXT_PUBLIC_VERSION=${{ github.event.inputs.version_tag }}" >> .env.production.local

      - name: 🏗️ Build Frontend
        run: |
          cd apps/frontend-nextjs
          npm run build

      - name: 🔥 Setup Firebase CLI
        run: npm install -g firebase-tools

      - name: 🚀 Deploy to Firebase
        run: |
          cd apps/frontend-nextjs
          
          # Criar arquivo de configuração Firebase
          cat > .firebaserc << EOF
          {
            "projects": {
              "default": "$PROJECT_ID"
            },
            "targets": {
              "$PROJECT_ID": {
                "hosting": {
                  "production": ["$FRONTEND_SITE"]
                }
              }
            }
          }
          EOF
          
          # Deploy usando configuração de produção
          firebase deploy \
            --only hosting:production \
            --config firebase.production.json \
            --project $PROJECT_ID \
            --token "$FIREBASE_TOKEN" \
            --non-interactive
          
          # Obter URL
          FRONTEND_URL="https://${FRONTEND_SITE}.web.app"
          echo "url=$FRONTEND_URL" >> $GITHUB_OUTPUT
          echo "🌐 Frontend URL: $FRONTEND_URL"
        env:
          FIREBASE_TOKEN: ${{ secrets.FIREBASE_TOKEN }}

  # =====================================
  # Testes de Smoke Production
  # =====================================
  production-smoke-tests:
    name: 🧪 Production Smoke Tests
    runs-on: ubuntu-latest
    needs: [deploy-backend-production, deploy-frontend-production, setup-production-monitoring]
    if: always() && (needs.deploy-backend-production.result == 'success' || needs.deploy-backend-production.result == 'skipped') && (needs.deploy-frontend-production.result == 'success' || needs.deploy-frontend-production.result == 'skipped')
    
    steps:
      - name: 📥 Checkout Code
        uses: actions/checkout@v4

      - name: 🧪 Production Smoke Tests
        run: |
          echo "🧪 Executando smoke tests de produção..."
          
          BACKEND_URL="${{ needs.deploy-backend-production.outputs.service-url }}"
          FRONTEND_URL="${{ needs.deploy-frontend-production.outputs.frontend-url }}"
          
          # Function to retry requests with delay
          retry_request() {
            local url=$1
            local max_attempts=5
            local delay=10
            
            for attempt in $(seq 1 $max_attempts); do
              echo "⏳ Tentativa $attempt/$max_attempts: $url"
              if curl -f -s --max-time 30 "$url" > /dev/null 2>&1; then
                echo "✅ Success: $url"
                return 0
              else
                echo "❌ Failed attempt $attempt"
                if [ $attempt -lt $max_attempts ]; then
                  echo "😴 Aguardando ${delay}s antes da próxima tentativa..."
                  sleep $delay
                fi
              fi
            done
            echo "🚨 CRITICAL: $url failed after $max_attempts attempts"
            return 1
          }
          
          # Critical health checks
          echo "🔍 Testando backend health..."
          retry_request "$BACKEND_URL/health" || exit 1
          
          sleep 5  # Delay between requests
          
          echo "🔍 Testando backend personas..."
          retry_request "$BACKEND_URL/api/v1/personas" || exit 1
          
          sleep 5  # Delay between requests
          
          if [ -n "$FRONTEND_URL" ]; then
            echo "🔍 Testando frontend..."
            retry_request "$FRONTEND_URL" || exit 1
          else
            echo "⚠️  Frontend URL not available"
            exit 1
          fi
          
          echo "✅ Todos os smoke tests de produção passaram"
          
          # Teste 3: Performance básico
          echo "3️⃣ Testing basic performance..."
          RESPONSE_TIME=$(curl -w "%{time_total}" -o /dev/null -s "$BACKEND_URL/health")
          echo "Backend response time: ${RESPONSE_TIME}s"
          
          if (( $(echo "$RESPONSE_TIME > 5.0" | bc -l) )); then
            echo "⚠️ Warning: Backend response time is high"
          else
            echo "✅ Backend response time is acceptable"
          fi
          
          echo "✅ Todos os smoke tests passaram"

  # =====================================
  # Setup Monitoramento Produção
  # =====================================
  setup-production-monitoring:
    name: 📈 Setup Production Monitoring
    runs-on: ubuntu-latest
    needs: [deploy-backend-production, deploy-frontend-production]
    if: always() && (needs.deploy-backend-production.result == 'success' || needs.deploy-backend-production.result == 'skipped') && (needs.deploy-frontend-production.result == 'success' || needs.deploy-frontend-production.result == 'skipped')
    
    steps:
      - name: 📥 Checkout Code
        uses: actions/checkout@v4

      - name: 🔐 Authenticate to Google Cloud
        uses: google-github-actions/auth@v2
        with:
          credentials_json: ${{ secrets.GCP_SA_KEY }}

      - name: 🛠️ Setup Cloud SDK
        uses: google-github-actions/setup-gcloud@v2

      - name: 🚨 Configure Production Alerts
        run: |
          echo "🚨 Configurando alertas de produção com integração Telegram..."
          
          chmod +x scripts/setup-gcp-alerts-with-secrets.sh
          bash scripts/setup/setup-gcp-alerts-with-secrets.sh \
            ${{ secrets.GCP_PROJECT_ID }} \
            "${{ secrets.TELEGRAM_BOT_TOKEN }}" \
            "${{ secrets.TELEGRAM_CHAT_ID }}"
        env:
          GCP_PROJECT_ID: ${{ secrets.GCP_PROJECT_ID }}

      - name: 📈 Create Production Dashboards
        run: |
          echo "📈 Criando dashboards de produção..."
          
          chmod +x scripts/create-simple-dashboards.sh
          bash scripts/maintenance/create-simple-dashboards.sh ${{ secrets.GCP_PROJECT_ID }}
          
          chmod +x scripts/create-remaining-dashboards.sh  
          bash scripts/maintenance/create-remaining-dashboards.sh ${{ secrets.GCP_PROJECT_ID }}

      - name: ✅ Verify Monitoring Setup
        run: |
          echo "✅ Verificando configuração de monitoramento..."
          
          # Verificar dashboards
          DASHBOARDS=$(gcloud monitoring dashboards list --format="value(name)" --limit=10)
          echo "📈 Dashboards encontrados:"
          echo "$DASHBOARDS"
          
          # Verificar políticas de alerta
          POLICIES=$(gcloud alpha monitoring policies list --format="value(name)" --limit=10)
          echo "🚨 Políticas de alerta encontradas:"
          echo "$POLICIES"
          
          # Verificar canais de notificação
          CHANNELS=$(gcloud alpha monitoring channels list --format="table(displayName,type)" --limit=5)
          echo "📢 Canais de notificação:"
          echo "$CHANNELS"

  # =====================================
  # Release Management
  # =====================================
  create-release:
    name: 🏷️ Create Release
    runs-on: ubuntu-latest
    needs: [production-smoke-tests]
    if: always() && needs.production-smoke-tests.result == 'success'
    
    steps:
      - name: 📥 Checkout Code
        uses: actions/checkout@v4

      - name: 🏷️ Create Git Tag
        run: |
          git config user.name "GitHub Actions"
          git config user.email "actions@github.com"
          
          # Criar tag da versão
          git tag -a "${{ github.event.inputs.version_tag }}" -m "Production release ${{ github.event.inputs.version_tag }}"
          git push origin "${{ github.event.inputs.version_tag }}"

      - name: 📋 Create GitHub Release
        uses: actions/create-release@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          tag_name: ${{ github.event.inputs.version_tag }}
          release_name: Release ${{ github.event.inputs.version_tag }}
          body: |
            ## 🚀 Production Release ${{ github.event.inputs.version_tag }}
            
            **Deployed to:**
            - Backend: ${{ needs.deploy-backend-production.outputs.service-url }}
            - Frontend: ${{ needs.deploy-frontend-production.outputs.frontend-url }}
            
            **Release Notes:**
            ${{ github.event.inputs.release_notes }}
            
            **Deployment Details:**
            - Commit: ${{ github.sha }}
            - Branch: ${{ github.ref_name }}
            - Deployed by: @${{ github.actor }}
            - Deployment time: ${{ github.event.head_commit.timestamp }}
            
            **Quality Gates:**
            - ✅ HML validation completed
            - ✅ Production smoke tests passed
            - ✅ Security scans passed
            - ✅ Performance tests passed
            - ✅ Observability system configured
            
            **Monitoring & Observability:**
            - ✅ Google Cloud Operations Suite active
            - ✅ Production dashboards created
            - ✅ Alert policies with Telegram integration
            - ✅ Structured logging and metrics
            
            ---
            🤖 *Release created automatically by GitHub Actions*
          draft: false
          prerelease: false

  # =====================================
  # Notificações
  # =====================================
  notify-production-deploy:
    name: 📢 Production Deploy Notifications
    runs-on: ubuntu-latest
    needs: [deploy-backend-production, deploy-frontend-production, setup-production-monitoring, production-smoke-tests, create-release]
    if: always()
    
    steps:
      - name: 📱 Telegram Notification (Success)
        if: needs.production-smoke-tests.result == 'success'
        run: |
          # Status do deploy
          STATUS="✅ PRODUÇÃO DEPLOYADA COM SUCESSO"
          EMOJI="🚀"
          
          # Commit info
          COMMIT_SHA=$(echo $GITHUB_SHA | cut -c1-7)
          
          # Mensagem de sucesso
          MESSAGE="$EMOJI *$STATUS*
          
          🏷️ *Versão:* \`${{ github.event.inputs.version_tag }}\`
          📦 *Commit:* \`$COMMIT_SHA\`
          👤 *Deployed by:* @${{ github.actor }}
          ⏰ *Timestamp:* \`$(date -u)\`
          
          🔗 *URLs de Produção:*
          * Backend: ${{ needs.deploy-backend-production.outputs.service-url }}
          * Frontend: ${{ needs.deploy-frontend-production.outputs.frontend-url }}
          
          📈 *Status dos Componentes:*
          * Backend: ${{ needs.deploy-backend-production.result }}
          * Frontend: ${{ needs.deploy-frontend-production.result }}
          * Monitoramento: ${{ needs.setup-production-monitoring.result }}
          * Smoke Tests: ${{ needs.production-smoke-tests.result }}
          * Release: ${{ needs.create-release.result }}
          
          🚨 *Sistema de Observabilidade:*
          * Google Cloud Operations Suite ✅
          * Alertas com Telegram configurados ✅
          * Dashboards de produção criados ✅
          * Métricas e logs estruturados ✅
          
          📝 *Release Notes:*
          ${{ github.event.inputs.release_notes }}
          
          🎉 *Sistema em produção e funcionando!*"
          
          # Enviar para Telegram
          curl -s -X POST "https://api.telegram.org/bot${{ secrets.TELEGRAM_BOT_TOKEN }}/sendMessage" \
            -d chat_id="${{ secrets.TELEGRAM_CHAT_ID }}" \
            -d text="$MESSAGE" \
            -d parse_mode="Markdown"

      - name: 📱 Telegram Notification (Failure)
        if: failure()
        run: |
          STATUS="❌ FALHA NO DEPLOY DE PRODUÇÃO"
          EMOJI="🚨"
          
          MESSAGE="$EMOJI *$STATUS*
          
          🏷️ *Versão:* \`${{ github.event.inputs.version_tag }}\`
          👤 *Tentativa por:* @${{ github.actor }}
          ⏰ *Timestamp:* \`$(date -u)\`
          
          📈 *Status dos Jobs:*
          * Validação: ${{ needs.pre-deployment-validation.result }}
          * Backend: ${{ needs.deploy-backend-production.result }}
          * Frontend: ${{ needs.deploy-frontend-production.result }}
          * Monitoramento: ${{ needs.setup-production-monitoring.result }}
          * Smoke Tests: ${{ needs.production-smoke-tests.result }}
          
          🔧 *Ações Necessárias:*
          1. Verificar logs do workflow
          2. Validar ambiente HML
          3. Corrigir problemas identificados
          4. Executar novo deploy
          
          ⚠️ *PRODUÇÃO NÃO AFETADA* - Deploy cancelado"
          
          # Enviar para Telegram
          curl -s -X POST "https://api.telegram.org/bot${{ secrets.TELEGRAM_BOT_TOKEN }}/sendMessage" \
            -d chat_id="${{ secrets.TELEGRAM_CHAT_ID }}" \
            -d text="$MESSAGE" \
            -d parse_mode="Markdown"

      - name: 📧 Email Notification (Critical Issues)
        if: failure()
        run: |
          echo "📧 Deploy de produção falhou - notificação crítica por email seria enviada"
          # Implementar notificação crítica por email para falhas de produção

# =====================================
# Workflow Configuration
# =====================================
concurrency:
  group: production-deploy
  cancel-in-progress: false