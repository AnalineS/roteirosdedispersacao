name: "[RELEASE] Sistema de Release Unificado"

on:
  workflow_run:
    workflows: ["[HML] Pipeline de Homologacao Completo", "[PROD] Pipeline de Producao Completo"]
    types: [completed]
  workflow_dispatch:
    inputs:
      release_type:
        description: 'Tipo de release'
        required: true
        default: 'patch'
        type: choice
        options:
          - 'major'
          - 'minor' 
          - 'patch'
          - 'hotfix'
      environment:
        description: 'Ambiente do release'
        required: true
        default: 'hml'
        type: choice
        options:
          - 'hml'
          - 'prod'
          - 'both'
      create_tag:
        description: 'Criar tag automaticamente'
        required: false
        default: true
        type: boolean

permissions:
  contents: write
  pull-requests: write
  actions: read
  repository-projects: write
  metadata: read

env:
  TELEGRAM_TOKEN: ${{ secrets.TELEGRAM_TOKEN }}
  TELEGRAM_CHAT_ID: ${{ secrets.TELEGRAM_CHAT_ID }}

jobs:
  analyze-release:
    name: "[ANALYZE] Analisar Release"
    runs-on: ubuntu-latest
    outputs:
      release-version: ${{ steps.version.outputs.version }}
      release-type: ${{ steps.analyze.outputs.type }}
      environment: ${{ steps.analyze.outputs.environment }}
      should-notify: ${{ steps.analyze.outputs.notify }}
      
    steps:
      - name: "[CHECKOUT] Checkout"
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}
          persist-credentials: true
          
      - name: "[ANALYZE] Determinar Tipo de Release"
        id: analyze
        run: |
          echo "Analisando contexto do release..."
          
          RELEASE_TYPE="patch"
          ENVIRONMENT="hml"
          SHOULD_NOTIFY="true"
          
          # Se triggered por workflow_run, analisar qual workflow
          if [ "${{ github.event_name }}" == "workflow_run" ]; then
            WORKFLOW_NAME="${{ github.event.workflow_run.name }}"
            
            if [[ "$WORKFLOW_NAME" == *"HML"* ]]; then
              ENVIRONMENT="hml"
              RELEASE_TYPE="patch"
            elif [[ "$WORKFLOW_NAME" == *"PROD"* ]]; then
              ENVIRONMENT="prod" 
              RELEASE_TYPE="minor"
            fi
            
            # Verificar se o workflow foi bem-sucedido
            if [ "${{ github.event.workflow_run.conclusion }}" != "success" ]; then
              echo "Workflow anterior falhou - nao criando release"
              SHOULD_NOTIFY="false"
              exit 0
            fi
          else
            # workflow_dispatch - usar inputs
            RELEASE_TYPE="${{ inputs.release_type }}"
            ENVIRONMENT="${{ inputs.environment }}"
          fi
          
          echo "type=$RELEASE_TYPE" >> $GITHUB_OUTPUT
          echo "environment=$ENVIRONMENT" >> $GITHUB_OUTPUT
          echo "notify=$SHOULD_NOTIFY" >> $GITHUB_OUTPUT
          
          echo "Tipo de release: $RELEASE_TYPE"
          echo "Ambiente: $ENVIRONMENT"
          
      - name: "[VERSION] Calcular Nova Versao"
        id: version
        run: |
          echo "Calculando nova versao..."
          
          # Buscar ultima tag
          LAST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "v0.0.0")
          echo "Ultima tag: $LAST_TAG"
          
          # Extrair versao numerica
          VERSION=$(echo $LAST_TAG | sed 's/v//')
          IFS='.' read -r MAJOR MINOR PATCH <<< "$VERSION"
          
          # Incrementar baseado no tipo
          RELEASE_TYPE="${{ steps.analyze.outputs.type }}"
          case $RELEASE_TYPE in
            "major")
              MAJOR=$((MAJOR + 1))
              MINOR=0
              PATCH=0
              ;;
            "minor")
              MINOR=$((MINOR + 1))
              PATCH=0
              ;;
            "patch"|"hotfix")
              PATCH=$((PATCH + 1))
              ;;
          esac
          
          NEW_VERSION="v${MAJOR}.${MINOR}.${PATCH}"
          
          # Para releases de ambiente, adicionar sufixo
          ENVIRONMENT="${{ steps.analyze.outputs.environment }}"
          if [ "$ENVIRONMENT" == "hml" ]; then
            NEW_VERSION="${NEW_VERSION}-hml"
          elif [ "$ENVIRONMENT" == "prod" ]; then
            NEW_VERSION="${NEW_VERSION}"  # Prod nao tem sufixo
          fi
          
          echo "version=$NEW_VERSION" >> $GITHUB_OUTPUT
          echo "Nova versao: $NEW_VERSION"

  generate-changelog:
    name: "[CHANGELOG] Gerar Changelog"
    runs-on: ubuntu-latest
    needs: analyze-release
    if: needs.analyze-release.outputs.should-notify == 'true'
    outputs:
      changelog: ${{ steps.changelog.outputs.content }}
      
    steps:
      - name: "[CHECKOUT] Checkout"
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          
      - name: "[CHANGELOG] Gerar Changelog"
        id: changelog
        run: |
          echo "Gerando changelog automatico..."
          
          # Buscar commits desde ultima tag
          LAST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "")
          
          if [ -n "$LAST_TAG" ]; then
            COMMITS=$(git log ${LAST_TAG}..HEAD --pretty=format:"- %s (%h)" --no-merges)
          else
            COMMITS=$(git log --pretty=format:"- %s (%h)" --no-merges -10)
          fi
          
          # Categorizar commits
          FEATURES=""
          FIXES=""
          OTHERS=""
          
          echo "$COMMITS" | while read -r line; do
            if echo "$line" | grep -q -i "feat\|feature\|add"; then
              FEATURES="$FEATURES$line\n"
            elif echo "$line" | grep -q -i "fix\|bug\|error"; then
              FIXES="$FIXES$line\n"  
            else
              OTHERS="$OTHERS$line\n"
            fi
          done
          
          # Montar changelog
          CHANGELOG="## ${{ needs.analyze-release.outputs.release-version }}\n\n"
          CHANGELOG="${CHANGELOG}**Ambiente:** ${{ needs.analyze-release.outputs.environment }}\n"
          CHANGELOG="${CHANGELOG}**Data:** $(date '+%Y-%m-%d %H:%M:%S')\n"
          CHANGELOG="${CHANGELOG}**Commit:** ${{ github.sha }}\n\n"
          
          if [ -n "$FEATURES" ]; then
            CHANGELOG="${CHANGELOG}### Novidades\n$FEATURES\n"
          fi
          
          if [ -n "$FIXES" ]; then
            CHANGELOG="${CHANGELOG}### Correcoes\n$FIXES\n"
          fi
          
          if [ -n "$OTHERS" ]; then
            CHANGELOG="${CHANGELOG}### Outras Mudancas\n$OTHERS\n"
          fi
          
          # Escapar para output
          CHANGELOG_ESCAPED=$(echo "$CHANGELOG" | sed ':a;N;$!ba;s/\n/\\n/g')
          echo "content=$CHANGELOG_ESCAPED" >> $GITHUB_OUTPUT
          
          echo "Changelog gerado com sucesso"

  create-release:
    name: "[RELEASE] Criar Release"
    runs-on: ubuntu-latest
    needs: [analyze-release, generate-changelog]
    if: needs.analyze-release.outputs.should-notify == 'true' && (inputs.create_tag != false)
    
    steps:
      - name: "[CHECKOUT] Checkout"
        uses: actions/checkout@v4
        
      - name: "[RELEASE] Criar GitHub Release"
        id: create_release
        uses: actions/create-release@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          tag_name: ${{ needs.analyze-release.outputs.release-version }}
          release_name: "Release ${{ needs.analyze-release.outputs.release-version }}"
          body: |
            ${{ needs.generate-changelog.outputs.changelog }}
            
            ---
            
            ### Informacoes Tecnicas
            - **Branch:** ${{ github.ref }}
            - **Workflow Trigger:** ${{ github.event_name }}
            - **Release Type:** ${{ needs.analyze-release.outputs.release-type }}
            - **Environment:** ${{ needs.analyze-release.outputs.environment }}
            
            ### Links Uteis
            - [Commits](https://github.com/${{ github.repository }}/compare/${{ needs.analyze-release.outputs.release-version }}...HEAD)
            - [Actions](https://github.com/${{ github.repository }}/actions)
          draft: false
          prerelease: ${{ contains(needs.analyze-release.outputs.release-version, 'hml') }}

  update-documentation:
    name: "[DOCS] Atualizar Documentacao"
    runs-on: ubuntu-latest
    needs: [analyze-release, create-release]
    if: needs.analyze-release.outputs.environment == 'prod'
    
    steps:
      - name: "[CHECKOUT] Checkout"
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          persist-credentials: true
          
      - name: "[DOCS] Atualizar Versao em Arquivos"
        run: |
          echo "Atualizando versao na documentacao..."
          
          NEW_VERSION="${{ needs.analyze-release.outputs.release-version }}"
          
          # Atualizar package.json se existir
          if [ -f "package.json" ]; then
            sed -i "s/\"version\": \".*\"/\"version\": \"${NEW_VERSION#v}\"/" package.json
            echo "package.json atualizado"
          fi
          
          # Atualizar README se existir
          if [ -f "README.md" ]; then
            sed -i "s/Version: .*/Version: $NEW_VERSION/" README.md
            echo "README.md atualizado"
          fi
          
          # Criar/atualizar CHANGELOG.md
          if [ ! -f "CHANGELOG.md" ]; then
            echo "# Changelog" > CHANGELOG.md
            echo "" >> CHANGELOG.md
          fi
          
          # Adicionar nova entrada no topo
          TEMP_FILE=$(mktemp)
          echo "# Changelog" > "$TEMP_FILE"
          echo "" >> "$TEMP_FILE"
          echo "${{ needs.generate-changelog.outputs.changelog }}" >> "$TEMP_FILE"
          echo "" >> "$TEMP_FILE"
          tail -n +3 CHANGELOG.md >> "$TEMP_FILE"
          mv "$TEMP_FILE" CHANGELOG.md
          
      - name: "[COMMIT] Commit Documentation Updates"
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          
          if git diff --quiet; then
            echo "Nenhuma alteracao na documentacao"
          else
            git add .
            git commit -m "docs: update version to ${{ needs.analyze-release.outputs.release-version }}"
            git push origin ${{ github.ref }}
            echo "Documentacao atualizada e commitada"
          fi

  notify-release:
    name: "[NOTIFY] Notificar Release"
    runs-on: ubuntu-latest  
    needs: [analyze-release, create-release, update-documentation]
    if: always() && needs.analyze-release.outputs.should-notify == 'true'
    
    steps:
      - name: "[NOTIFY] Telegram Notification"
        run: |
          VERSION="${{ needs.analyze-release.outputs.release-version }}"
          ENVIRONMENT="${{ needs.analyze-release.outputs.environment }}"
          RELEASE_TYPE="${{ needs.analyze-release.outputs.release-type }}"
          
          # Determinar emoji baseado no ambiente
          if [ "$ENVIRONMENT" == "prod" ]; then
            EMOJI="🚀"
            ENV_NAME="PRODUCAO"
          else
            EMOJI="🧪"  
            ENV_NAME="HOMOLOGACAO"
          fi
          
          # Determinar status
          if [ "${{ needs.create-release.result }}" == "success" ]; then
            STATUS="SUCCESS"
            STATUS_EMOJI="✅"
          else
            STATUS="FAILED"
            STATUS_EMOJI="❌"
          fi
          
          # Montar mensagem
          MESSAGE="$EMOJI *RELEASE $STATUS* $STATUS_EMOJI"
          MESSAGE="$MESSAGE%0A%0A*Versao:* $VERSION"
          MESSAGE="$MESSAGE%0A*Ambiente:* $ENV_NAME"
          MESSAGE="$MESSAGE%0A*Tipo:* $RELEASE_TYPE"
          MESSAGE="$MESSAGE%0A*Branch:* ${{ github.ref }}"
          MESSAGE="$MESSAGE%0A*Commit:* ${{ github.sha }}"
          
          if [ "$STATUS" == "SUCCESS" ]; then
            MESSAGE="$MESSAGE%0A%0A[Ver Release](https://github.com/${{ github.repository }}/releases/tag/$VERSION)"
          fi
          
          curl -s -X POST "https://api.telegram.org/bot$TELEGRAM_TOKEN/sendMessage" \
            -d chat_id="$TELEGRAM_CHAT_ID" \
            -d text="$MESSAGE" \
            -d parse_mode="Markdown"

  cleanup-old-releases:
    name: "[CLEANUP] Limpeza de Releases Antigos"
    runs-on: ubuntu-latest
    needs: create-release
    if: needs.create-release.result == 'success'
    
    steps:
      - name: "[CHECKOUT] Checkout"
        uses: actions/checkout@v4
        
      - name: "[CLEANUP] Remover Releases Antigos (HML)"
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          echo "Limpando releases antigos de homologacao..."
          
          # Listar todas as releases de HML (pre-releases)
          HML_RELEASES=$(gh release list --limit 50 | grep "hml" | head -n -5 | cut -f1)
          
          # Deletar releases antigas de HML (manter apenas as 5 mais recentes)
          for release in $HML_RELEASES; do
            echo "Removendo release antigo de HML: $release"
            gh release delete "$release" --yes || echo "Erro ao deletar $release"
          done
          
          echo "Limpeza de releases de HML concluida"

concurrency:
  group: release-manager
  cancel-in-progress: false